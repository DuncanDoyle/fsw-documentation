= FSW Architectures
:author: Jorge Morales 
:email: <jmorales@redhat.com>
:description: FSW training
:revdate: 2014-07-17
:revnumber: 0.1
:icons: font
:imagesdir: ./images
:figure-caption!:
:deckjs_theme: beamer
// web-2.0
//:deckjs_transition: horizontal-slide
//:pygments:
//:pygments_style: native
:scrollable:
// :linkcss: ./css/redhat.css
//:count_nested:

== Architecture - Topologies
* Simple topology (All in one)
* Environmental topology
* Environmental topology with unified governance

== Simple topology (All in one)
This topology deploys all the functions in the same boxes, a set of 2 or more boxes (to have clustering) and it is not recommended as the production approach, but rather for PoC and demoing.

image::fsw/architecture/FSW_deployment_allinone.jpg[FSW Architecture]

This topology is a simple topology and will consist of:

* A cluster of servers for SwitchYard, rtGov + dtGov.
* We will typically front this cluster with a Load Balancer. For this we usually have two options, a Hardware load balancer (typically this is clustered) or an httpd+mod_cluster (usually in an HA manner, A/A or A/P)
* We also have a cluster of databases (amongst those supported by the product) in a clustered way, for HA.

Httpd servers and database servers ca be co-located on the same boxes as the FSW servers, so reducing the required amount of boxes needed for this.

We need to take into account for this topology additional constraints such as:

* Having a separate messaging topology included in the solution and connected from SwitchYard clusters via JMS bridge or ActiveMQ/HornetQ jca adapter.
* Having shared storage for file based type of services

== Environmental topology
This topology deploys every function into every existing environment in a clustered manner per functionality.

image::fsw/architecture/FSW_deployment_environmental.jpg[FSW Architecture]

In every environment we will have:

* A large cluster of servers for SwitchYard (this servers include rtGov client) that will do the service execution.
* We will typically front this cluster with a Load Balancer. For this we usually have two options, a Hardware load balancer (typically this is clustered) or an httpd+mod_cluster (usually in an HA manner, A/A or A/P)
* A cluster of RTGov servers (for HA) that will be doing runtime governance analisys. This cluster will be A/P and accessed through a VIP.
* We also have a cluster of databases (amongst those supported by the product) in a clustered way, for HA.
* A cluster for Design Time Governance that will orchestrate the state of services in that environment. Promotion of artifacts amongst environments will be done manually, and thus the solely purpose of this DTGov cluster in the environment is to provide with the S-RAMP storage capabilities for artifacts and metadata.

Usually these environments (dev, qa, test, stage, preprod, prod,...) will not be the same in terms of size and capabilities, so Development environment tends to be much smaller in terms of number of boxes and capabilities of those boxes (cores/cpus, ram,...).

We need to take into account for this topology additional constraints such as:

* Having a separate messaging topology included in the solution and connected from SwitchYard clusters via JMS bridge or ActiveMQ/HornetQ jca adapter.
* Having shared storage for file based type of services

== Environmental topology with unified governance
This topology deploys clusters of main functions per existing environment and shares a common layer (cluster/environment) for design time governance (DTGov) responsibilities.

image::fsw/architecture/FSW_deployment.jpg[FSW Architecture]

In every environment we will have:

* A large cluster of servers for SwitchYard (this servers include rtGov client) that will do the service execution.
* We will typically front this cluster with a Load Balancer. For this we usually have two options, a Hardware load balancer (typically this is clustered) or an httpd+mod_cluster (usually in an HA manner, A/A or A/P)
* A cluster of RTGov servers (for HA) that will be doing runtime governance analisys. This cluster will be A/P and accessed through a VIP.
* We also have a cluster of databases (amongst those supported by the product) in a clustered way, for HA.
 
Also, we will lie down a shared environment for Design Time Governance that will orchestrate the state of services between the different environments. This environment is one single environment and can be co-located in any of the other environments, and then making advantage of the load balancing and database capabilities already available in that environment.
 
Usually this environments will not be the same in terms of size and capabilities, so Development environment tends to be much smaller in terms of number of boxes and capabilities of those boxes (cores/cpus, ram,...)
 
We need to take into account for this topology additional constraints such as:

* Having a separate messaging topology included in the solution and connected from SwitchYard clusters via JMS bridge or ActiveMQ/HornetQ jca adapter.
* Having shared storage for file based type of services

== Adding ActiveMQ
Usually, when adding to the architecture a messaging broker, you would like to add it in a HA way, and running in separate processes.

There are multiple ways of adding a messaging broker (master/slave, network of brokers,...) but all of them, if using ActiveMQ, requires that the communication between FSW (SwitchYard) and the messaging brokers is done with the ActiveMQ JCA resource adapter.

image::fsw/architecture/FSW_ActiveMQ.png[FSW + ActiveMQ]

== Complete FSW stack
This topology deploys clusters of main functions per existing environment and shares a common layer (cluster/environment) for design time governance (DTGov) responsibilities.

image::fsw/architecture/FSW_deployment_environmental_messaging_jon.jpg[Complete architecture]

In every environment we will have:

* A large cluster of servers for SwitchYard (this servers include rtGov client) that will do the service execution.
* We will typically front this cluster with a Load Balancer. For this we usually have two options, a Hardware load balancer (typically this is clustered) or an httpd+mod_cluster (usually in an HA manner, A/A or A/P)
* A cluster of RTGov servers (for HA) that will be doing runtime governance analisys. This cluster will be A/P and accessed through a VIP.
* We also have a cluster of databases (amongst those supported by the product) in a clustered way, for HA.
* A cluster of messaging brokers (With their requirements in terms of shared storage/database for HA).
* A cluster of management and monitoring servers with JBoss OperationNetwork (JON) 
 
Also, we will lie down a shared environment for Design Time Governance that will orchestrate the state of services between the different environments. This environment is one single environment and can be co-located in any of the other environments, and then making advantage of the load balancing and database capabilities already available in that environment.
 
Usually this environments will not be the same in terms of size and capabilities, so Development environment tends to be much smaller in terms of number of boxes and capabilities of those boxes (cores/cpus, ram,...)

== Continuous Delivery with FSW
FSW is a great product, and incorporates in the suite a Governance solution for services lifecycle. We usually don't have a clear picture of how to map this product to user requirements, and how to integrate into the customer environments or way of doing things.
What I describe here are some examples of use cases that can be done with DTGov to enable Continuous Delivery of services for a customer. Of course, these are just examples, and every customer/organization will have their specific concerns or tools or way of working, so this process *ALWAYS* needs to be tailored for the customer. But you can use these examples to get into the conversation with the customer.

== Tag Final version after all testing phases
This example here assumes the customer will go through all their testing phases using a "Snapshot" or not "final" version of the artifact, and will tag it as Final just when the artifact is ready to be promoted to the production environment. If testing at some point fails, version will not be bumped.

image::fsw/architecture/DTGov_CD.png[CD with FSW]

. Developer commit/pushes their development to the VCS (Version Control System) they are using (Git, SVN,...)
.. To note that developer will use artifact repository to fetch dependencies. For this example, it will use Nexus for released versions and dtGov for snapshots. (An option can be to have nexus proxy to dtGov for the Snapshots)
. Continuous Integration server fetches latest code from VCS and trigger the execution of the build job that will build and do unit tests on the code. If everything works fine, and all tests pass, it will deploy the generated artifact to DTGov via maven deployment API.
. DTGov will start executing the configured workflow for this kind of service.
.. DTGov can have multiple workflows for different kind of services.
. DTGov will deploy/install/copy the artifact to the target environment with the configured deployment process (Using maven, JBoss cli, file copy or JON)
. Workflow will be in waiting state for the configured used to functional validate the development in the corresponding environment (dev in this example).
. Once the user has validated the development doing the pertinent functional/integration/performance/xxx tests it will approve or reject the task in "DTGov task inbox" which will trigger a finish of the workflow (in case of reject) or continue the workflow (in cse of approve).
.. Bundled workflow (OOTB) sends an email notification with the result of the approval/rejection action taken.
. DTGov workflow continues (in case of approval) and it will deploy to next configured environment, and will create a task for the corresponding user.
. Corresponding user will validate the development, as before.
. User will approve or reject, as before. And so forth with every environment but the last one.
. This example assumes that no automatic deployment can be made to production systems, so part of the workflow, the corresponding to "PROD" environment, will trigger a job in the CI server to release the software (development) and do whatever is appropriate for the task.
. This CI release job, will tag the version in the VCS used.
. It will build the tagged version and it will deploy it to the Artifact repository to the released group for the corresponding project. This way, artifact is accessible.
. Ops guy (team) will get the artifact from the artifact repository
. And it will install it to the "PROD" environment with their "Pass to Production" procedures.

== Tag Final version before all testing phases
 
This example here assumes the customer will go through all their testing phases using a tagged version of the artifact. If testing at some point fails, version will be bumped, and a version that will never get into production will have been produced.

image::fsw/architecture/DTGov_CD-TagFirst.png[CD with FSW]

. Developer commit/pushes their development to the VCS (Version Control System) they are using (Git, SVN,...)
.. To note that developer will use artifact repository to fetch dependencies. For this example, it will use Nexus for released versions and dtGov for snapshots. (An option can be to have nexus proxy to dtGov for the Snapshots)
. Continuous Integration server fetches latest code from VCS and trigger the execution of the build job that will build and do unit tests on the code.
. If everything works fine, the release will be tagged.
. CI server will deploy the generated artifact to DTGov via maven deployment API. DTGov will start executing the configured workflow for this kind of service.
.. DTGov can have multiple workflows for different kind of services.
. DTGov will deploy/install/copy the artifact to the target environment with the configured deployment process (Using maven, JBoss cli, file copy or JON)
. Workflow will be in waiting state for the configured used to functional validate the development in the corresponding environment (dev in this example).
. Once the user has validated the development doing the pertinent functional/integration/performance/xxx tests it will approve or reject the task in "DTGov task inbox" which will trigger a finish of the workflow (in case of reject) or continue the workflow (in cse of approve).
.. Bundled workflow (OOTB) sends an email notification with the result of the approval/rejection action taken.
. DTGov workflow continues (in case of approval) and it will deploy to next configured environment, and will create a task for the corresponding user.
. Corresponding user will validate the development, as before.
. User will approve or reject, as before. And so forth with every environment but the last one.
. This example assumes that no automatic deployment can be made to production systems, so part of the workflow, the corresponding to "PROD" environment, will deploy install the "verified" artifact into the artifact repository (nexus).
. Ops guy (team) will get the artifact from the artifact repository
. And it will install it to the "PROD" environment with their "Pass to Production" procedures.

== DT With FSW CAVEATS
* As I said, there is no golden rule on how to do CI/CD with DTGov. Every SCM (Software Configuration Management) tools has their specifics, and these here presented are shown to be valid with Jenkins as CI server, Git as VCS and Nexus as artifact repository.
* Deployment process can be more complicated than what is here expressed, as SwitchYard doesn't allow yet for domain mode (as of FSW 6.0.0), so installation of the artifact to the environment can be tricky. If using JON, things seem simpler.
* Configuration of development station has to be taken into account and configured accordingly to their artifact repository and to the way of grouping their dependencies.
* Even DTGov can be used as maven server for artifact dependencies, we assume for this workflow that nexus will be the single source of "Final" artifacts, as this simplifies maven "settings.xml" configuration for developers. Nexus can proxy DTGov as a named repository.
* This is an example based on the OOTB workflow with the difference that promotion to Prod environment is not automatic. (As I have yet to see a company that does allow for automatic deployment to prod systems, so I feel this is more realistic).

// vim: set syntax=asciidoc:
