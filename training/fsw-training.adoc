FSW Training
============
:author: Jorge Morales 
:email: <jmorales@redhat.com>
:description: FSW training
:revdate: 2014-07-17
:revnumber: 0.1
:icons: font
:imagesdir: ./images
:figure-caption!:
:deckjs_theme: beamer
// web-2.0
//:deckjs_transition: horizontal-slide
//:pygments:
//:pygments_style: native
:scrollable:
// :linkcss: ./css/redhat.css
//:count_nested:

== FSW from the Red Hat website

[quote, Red Hat website, http://www.redhat.com/es/technologies/jboss-middleware/fuse-service-works]
____
Red Hat® JBoss® Fuse Service Works is a platform that creates reusable, changeable, and flexible business services that hide the complexity of connecting to different applications in your enterprise. It sets the stage for faster and easier cloud apps, mobile apps, and business process development projects.

JBoss Fuse Service Works combines technical innovations from leading open source projects with the experience and support you expect from a world-class software provider.

image::fsw/FSW_benefits.png[FSW benefits]
____

== FSW from the JBoss.org

[quote, JBoss.org, http://www.jboss.org/products/fsw/overview/]
____
An open source service design, development and integration platform that speeds up cloud integration.

JBoss Fuse Service Works is Red Hat’s middleware solution for application integration, messaging, SOA, and service governance requirements. It combines the core ESB technology from JBoss Fuse and technical innovations from popular open source communities like SwitchYard and Overlord.
____

== From the official documentation

[quote, Red Hat product documentation, https://access.redhat.com/documentation/en-US/Red_Hat_JBoss_Fuse_Service_Works/6/html/User_Guide/chap-Preface.html]
____
Red Hat JBoss Fuse Service Works is a platform for developing enterprise application integration (EAI) and service-oriented architecture (SOA) solutions. It consists of a service component framework, business rules/complex event processing, life-cycle governance, runtime governance and process automation. It is built on the same core as JBoss Fuse with enterprise messaging, Camel and CXF so, therefore, users can use it to design, deploy, integrate and orchestrate business services.
____


== FSW Core Capabilities
The benefits of using Red Hat JBoss Fuse Service Works include the following:

Enterprise Integration Pattern (EIP) Based Development:: The versatile EIP framework is implemented in routing and transformation processes for faster and more efficient integration solutions.
High Performance Messaging:: A high performance messaging broker supports messaging patterns such as publish-subscribe, point-to-point and store-forward, and multiple cross language clients.
Service Development:: The web services framework exposes integration assets as services and calls external services, supporting all major web services standards. It also supports RESTful calls.
Structured Service Development:: A lightweight service development framework provides full lifecycle support for developing, deploying, and managing service-based applications.
Automatable Registry with Workflow:: Manage the lifecycle of services from design, development and deployment by defining, exposing and enforcing rules or policies.
Business Transaction Monitoring:: Capture service activity information, define and collect metrics, and define alerts and SLAs.
Report a bug:: (Just kidding)

=== FSW as System Integration
Integrating your major business systems into a cohesive infrastructure can be a challenge, especially when you have legacy applications. Red Hat JBoss Fuse Service Works has a number of ways enable you to integrate both new and legacy applications. Development is simplified with a transparent, lightweight service framework which uses EIP technology. This allows developers to focus on higher order concepts while still working with familiar technologies such as Apache Camel, BPEL, BPMN or POJOs. To reduce the operational costs of production and maintenance, the platform utilizes automatable, content-aware repository and service activity monitoring. These support the entire service lifecycle and development, QA and production teams with run-time and design-time visibility, monitoring and alerting.

== What is integration

[quote, Wikipedia, http://en.wikipedia.org/wiki/Systems_integration]
____
System integration is defined as the process of bringing together the component subsystems into one system and ensuring that the subsystems function together as a system.

The system integrator brings together discrete systems utilizing a variety of techniques such as computer networking, enterprise application integration, business process management or manual programming.
____

== What is applications integration

[quote, MuleSoft, https://www.mulesoft.com/resources/esb/applications-integration]
____
Applications integration (or enterprise application integration) is the sharing of processes and data among different applications in an enterprise. For both small and large organizations alike, it has become a mission-critical priority to connect disparate applications and leverage application collaboration across the enterprise in order to improve overall business efficiency, enhance scalability, and reduce IT costs.
____

== What is governance

[quote, Wikipedia, http://en.wikipedia.org/wiki/Governance]
____
Governance refers to "all processes of governing, whether undertaken by a government, market or network, whether over a family, tribe, formal or informal organization or territory and whether through laws, norms, power or language." It relates to processes and decisions that seek to define actions, grant power and verify performance.
____

== Training contents

* SwitchYard
* RTGov
* DTGov

== FSW Overview - Components

image:fsw/fsw_component_overview.png[FSW component overview]

== FSW Overview - Layers

image:fsw/fsw_layers.png[FSW layers]

== FSW Overview - Architecture 

image:fsw/fsw_architecture.png[FSW architecture]

== SwitchYard

image::switchyard/switchyard.png[] 

* SCA (Service, component, reference, binding)
* Components (Service implementations)
* Bindings (Gateways)
* Transformations (Java, JAXB, JSON, Smooks, XSLT, ...)
* Validations (Java validations, XML Validation)
* Properties
* Policies (transaction, )
* Security
* Clustering
* RemoteInvoker
* Serialization
* Extensions 

== SwitchYard - SCA

____
SwitchYard is a component-based *development framework* focused on building *structured*, *maintainable services* and *applications* using the concepts and best practices of SOA. It works with Apache Camel to provide a *fast*, *simple*, *flexible* integration runtime with *comprehensive* connectivity and transports. A *uniform* application model *augments* Apache Camel, *joining* Java EE, BPM, rules, orchestration, and routing into a *cohesive* development model and runtime. 

Common functionality and cross-cutting concerns - validation, transformation and policy - are isolated from business logic and handled declaratively. This ensures *consistency* and *eliminates duplication*, offering developers a clear view of the structure and relationships of services in an integration application.
____

== SwitchYard - SCA

image::switchyard/sca/app.jpg[SwitchYard application]

== Composite
A composite is displayed as a light blue rectangle and represents the boundary between what's inside your application and what's outside your application. A SwitchYard application consists of exactly one composite that has a name and a targetNamespace. The targetNamespace value is important as it allows names defined locally in the application (e.g. service names) to be qualified and unique within a SwitchYard runtime.

== Composite
image::switchyard/sca/composite.jpg[composite]

[source,xml]
----
<sca:composite name="example" targetNamespace="urn:example:switchyard:1.0">
</sca:composite>
----

== Component
A component is a modular container for application logic and consists of the following:

* 0 or 1 component service definitions
* 0 to many component reference definitions
* 1 implementation

Services and references allow a component to interact with other components, while the implementation provides the actual logic for providing and/or consuming services.

== Component
image::switchyard/sca/component.jpg[component]

[source,xml]
----
<sca:component name="Routing">
</sca:component>
----

== Implementation
An implementation acts as the 'brain' of a service component and it is how implement your application logic. The following implementation options are available:

* *Bean*: allows a CDI Bean to consume or provide services using annotations.
* *Camel*: EIP-style routing and service composition using the XML or Java DSL in Apache Camel.
* *BPMN 2*: service orchestration and human task integration expressed as BPMN 2 and executed using jBPM.
* *BPEL Process*: web service orchestration using the OASIS Business Process Execution Language.
* *Rules*: decision services based on Drools.

Implementations are private to a component, which means external consumers and providers are not aware of the details of a component's implementation (implementation-hiding).  All interactions with other components within an application and with external services are handled through component services and references.

== Implementation
image::switchyard/sca/implementations.jpg[implementation]

[source,xml]
----
<sca:component name="Routing">
   <camel:implementation.camel>
      <camel:xml path="RoutingService.xml"/>
   </camel:implementation.camel>
</sca:component>
----

== Component Service
A component service is used to expose the functionality of an implementation as a service. All component services have a contract, which can be a Java interface, WSDL portType definition, or a set of named data types (interface.esb). Component services are private to an application, which means a component service can only be invoked by other components in the same application. In order to expose a component service to consumers external to the application, a component service can be 'promoted' to a composite service. A component service can be promoted multiple times to create different composite services.

== Component Service
image::switchyard/sca/component-service.jpg[Component service]

[source,xml]
----
<sca:component name="Routing">
   <camel:implementation.camel>
      <camel:xml path="route.xml"/>
   </camel:implementation.camel>
   <sca:service name="ServiceA">
      <sca:interface.java interface="org.example.ServiceA"/>
   </sca:service>
</sca:component>
----

== Composite Service
A composite service represents an application service which is visible to other applications. A composite service can only be realized by promoting a component service within the application. The name and the interface of the composite service can be different from the component service. If the interface, or contract, of the composite service is different from the component service, be aware that a transformation may be required to map between the types defined in each interface. In our example application, the component service has a Java interface while the composite service has a WSDL interface. This means we would need to declare a transformer which maps between XML and Java to resolve the data type mismatch.

== Composite Service
image::switchyard/sca/composite-service.jpg[Composite service]

[source,xml]
----
<sca:composite name="example" targetNamespace="urn:example:switchyard:1.0">
   <sca:service name="ServiceA" promote="Routing/ServiceA">
      <sca:interface.wsdl interface="ServiceA.wsdl#wsdl.porttype(ServiceAPortType)"/>
   </sca:service>
</sca:composite>
----

== Service Binding
A service binding is used to define an access method for a composite service. Composite services can have multiple bindings, which allows a single service to be accessed in different ways. In most cases, a service binding represents a protocol/transport adapter (e.g. SOAP, JMS, REST). An important exception to this rule is the SCA binding, which allows services across applications in the same runtime to be wired together in memory. Regardless of the underlying binding details, a binding must always be used to facilitate inter-application communication in SwitchYard.

== Service Binding
image::switchyard/sca/service-binding.jpg[Service binding]

[source,xml]
----
<sca:composite name="example" targetNamespace="urn:example:switchyard:1.0">
   <sca:service name="ServiceA" promote="Routing/ServiceA">
      <sca:interface.wsdl interface="ServiceA.wsdl#wsdl.porttype(ServiceAPortType)"/>
      <soap:binding.soap>
        <soap:wsdl>ServiceA.wsdl</soap:wsdl>
      </soap:binding.soap>
   </sca:service>
</sca:composite>
----

== Component Reference
A component reference allows a component to consume other services. A component reference can be wired to a service offered by another component in the same application or it can be wired to services outside the application via a composite reference. Similar to component services, all component references have a contract with allows a component to invoke services without knowing implementation or binding details. The picture below shows an example of wiring a reference on the Routing component to a service offered by the Bean component.

== Component Reference
image::switchyard/sca/component-reference.jpg[Component reference]

[source,xml]
----
<sca:component name="Routing">
   <camel:implementation.camel>
      <camel:xml path="route.xml"/>
   </camel:implementation.camel>
   <sca:service name="ServiceA">
      <sca:interface.java interface="org.example.ServiceA"/>
   </sca:service>
   <sca:reference name="ServiceC">
      <sca:interface.java interface="org.example.ServiceC"/>
   </sca:reference>
</sca:component>
----

== Composite Reference
A composite reference allows a component reference to be wired to a service outside the application. Similar to composite services, bindings are used with composite references to specify the communication method for invoking the external service.

== Composite Reference
image::switchyard/sca/composite-reference.jpg[Composite reference]

[source,xml]
----
<sca:composite name="example" targetNamespace="urn:example:switchyard:1.0">
   <sca:reference name="ReferenceB" multiplicity="0..1" promote="Routing/ServiceB">
      <sca:interface.java interface="org.example.ServiceB"/>
   </sca:reference>
</sca:composite>
----

== Reference Bindings
A reference binding is used to define an access method for an external service via a composite reference. Unlike service bindings, there can only be one binding for each composite reference. The set of bindings available for references is identical to the set of bindings available for services, although the configuration values for a given binding may be different depending on whether it's used as a service binding or a reference binding.

== Reference Bindings
image::switchyard/sca/reference-binding.jpg[Reference binding]

[source,xml]
----
<sca:composite name="example" targetNamespace="urn:example:switchyard:1.0">
   <sca:reference name="ReferenceB" multiplicity="0..1" promote="Routing/ServiceB">
      <sca:interface.java interface="org.example.ServiceB"/>
         <jms:binding.jms>
         <jms:queue>MyQueue</jms:queue>
         <jms:connectionFactory>#ConnectionFactory</jms:connectionFactory>
      </jms:binding.jms>
   </sca:reference>
</sca:composite>
----

== Create an application

image::switchyard/service_creation/1.png[To create this service]

== Create a composite

image::switchyard/service_creation/2.png[Create a composite]

== Add a component

image::switchyard/service_creation/3.png[Add a component]

== Add more components and link them

image::switchyard/service_creation/4.png[Add more components and link them]

== Even more components

image::switchyard/service_creation/5.png[Even more components]

== Expose/call your service

image::switchyard/service_creation/6.png[Expose/call your service]

== Invoke/Call external applications (references)

image::switchyard/service_creation/1.png[Call external applications]

== Configure every declarative aspect

* Properties
* Policies
* Transformations
* Validation
* ...

== Components - What we have
 **  Component contract interfaces: wsdl, java, esb
 **  Bean (Java)
 **  Camel (java, xml)
 **  BPEL (XPath functions)
 **  BPM
 **  Rules (Knowledge services)

== Contracts

Every service needs to have it's contract defined (API).

This contracts can be defined in on of 3 ways:

* Java 
* WSDL
* SOA

NOTE: SwitcyYard require a one parameter per method in the contract definition

== Java contract

.Definition
image::switchyard/contracts/java_contract.png[Java contract]

.Implementation
image::switchyard/contracts/java_contract_impl.png[Java contract Implementation]

== WSDL contract

.Definition
image::switchyard/contracts/wsdl_contract.png[WSDL contract]

.Implementation
image::switchyard/contracts/wsdl_contract_impl.png[WSDL contract Implementation]

== ESB contract

.Definition and implementation
image::switchyard/contracts/esb_contract.png[ESB contract]

== Bean Component
The Bean Component is a pluggable container in SwitchYard which allows Java classes (or beans) to provide and consume services. This means that you can implement a service by simply annotating a Java class. It also means you can consume a service by injecting a reference to that service directly into your Java class

image::switchyard/components/bean/bean_component.png[Bean component]

== Creating a Bean service
To create a new Bean service you only need a few pieces of information:

* *Name*: the name of the Java class for your bean service.
* *Service Name*: the name of the service your bean will provide.
* *Interface*: the contract for the service being provided.  Java is the only valid interface type for bean services.

== Creating a Bean service
image::switchyard/components/bean/new-bean.jpg[New bean component]

== Creating a Bean service

[source,java]
----
package com.example.switchyard.docs;
 
import org.switchyard.component.bean.Service;
 
@Service(Example.class)
public class ExampleBean implements Example {
 
}
----

The @Service annotation allows the SwitchYard CDI Extension to discover your bean at runtime and register it as a service. The value of the annotatio represents the service contract for the service. 

 Every bean service must have an @Service annotation with a value identifying the service interface for the service.
 
== Consuming a Bean service
In addition to providing a service in SwitchYard, beans can also consume other services. These services can be provided in the same application by other implementations, or they could be wired to gateway bindings to invoke services over JMS, SOAP, FTP, etc. The SwitchYard runtime handles the resolution of the service reference to a concrete service, allowing your service logic to remain blissfully ignorant. Invocations made through this reference are routed through the SwitchYard exchange mechanism.

[source,java]
----
@Inject @Reference
private SimpleService service;

public void consumeSomeService(String consumerName) {
   service.sayHello("Hello " + consumerName);
}
----

== Consuming a Bean service
By default, SwitchYard expects a service reference to be declared with a name which matches the Java type used for the reference. In the event where the service reference name is different from the type name of the contract, the @Reference annotation can accept a service name

[source,java]
----
@Inject @Reference("urn:com.example.services:SimpleService:1.0")
private SimpleService service;

public void consumeSomeService(String consumerName) {
   service.sayHello("Hello " + consumerName);
}
----

== Consuming a Bean service

image::switchyard/components/bean/consume_service_1.png[]

== Consuming a Bean service

image::switchyard/components/bean/consume_service_2.png[]

== Consuming a Bean service

image::switchyard/components/bean/consume_service_3.png[]

== Consuming a Bean service

image::switchyard/components/bean/consume_service_4.png[]

== Reference Invoker
The default behavior of @Reference is to inject a reference using the Java interface of the reference contract. This is adequate for most cases, but it does not allow you to access SwitchYard API constructs like the Message and Context interfaces. 

If you need to access to an attachment or a context property when invoking a reference from a Bean service, then you will want to use a *ReferenceInvoker*. To use a ReferenceInvoker, all you need to do is _replace the service contract interface type with a ReferenceInvoker type and SwitchYard will automatically inject the correct instance_.

[source,java]
----
@Inject @Reference("urn:com.example.services:SimpleService:1.0")
private ReferenceInvoker service;

public void consumeSomeService(String consumerName) {
   service.newInvocation("sayHello")
      .setProperty("myHeader", "myValue")
      .invoke(consumerName);
}
----

 Note how the ReferenceInvoker instance is used to create a ReferenceInvocation using the newInvocation() method. A new instance of ReferenceInvocation should be created each time you want to invoke a service using ReferenceInvoker.

== Switchyard - Camel Component
Camel services allow you to leverage the core routing engine inside of Apache Camel to route between services in SwitchYard. All of the EIP and core routing support in Camel is available to your service implementation. Each Camel route is exposed as a service within SwitchYard, which means it has a well-defined contract and can be injected into any other service in the runtime.

There are 2 implementations:

* Java DSL
* XML DSL

Tips:

* There is only one route per service. (More routes can be created, only one component entry point)
* The consumer or "from" endpoint in a route is always a "switchyard" endpoint and the endpoint name must equal the service name.  This is default behavior in the tooling.
* To consume other services from within your route, only use "switchyard" consumer (i.e. "to") endpoints. This keeps your routing logic independent of the binding details for consumed services.

== Switchyard - Creating a Camel Service

 TODO: Create this


== Switchyard - Camel Component Java DSL

[source,java]
----
package com.example.switchyard.docs;
 
import org.apache.camel.builder.RouteBuilder;
 
public class CamelServiceRoute extends RouteBuilder {
    /**
     * The Camel route is configured via this method.  The from:
     * endpoint is required to be a SwitchYard service.
     */
    public void configure() {
        // TODO Auto-generated method stub
        from("switchyard://Example").log(
                "Received message for 'Example' : ${body}");
    }
}
----

 There are no SwitchYard-specific classes or APIs used for Java DSL route; the route class is identical in signature to what you would use with Apache Camel directly.

== Switchyard - Camel Component XMl DSL

[source,xml]
----
<?xml version="1.0" encoding="ASCII"?>
<route xmlns="http://camel.apache.org/schema/spring">
   <from uri="switchyard://Example"/>
   <log message="Example - message received: ${body}"/>
</route>
----

 The XML routing syntax is identical to what you would use with Apache Camel directly and conforms to the Camel schema for <route> definition

== Switchyard - Consuming services from Camel routes
Invoking another service from within your Camel route can be done by using the SwitchYard producer endpoint (switchyard://) within your route.  Endpoint configuration is very straightforward:

[source,java]
----
switchyard://[service-name]?operationName=[operation-name]
----

* *service-name*: name of the SwitchYard service. This value needs to match the name of a service reference defined on the service component for the route.
* *operation-name*: name of the service operation to be invoked. This is only used on references and is optional if the target service only has a single operation.

== SwitchYard - Scripting languages in Camel
Because of 3rd party dependencies, SwitchYard supports only following languages:

* BeanShell
* JavaScript
* Groovy
* Ruby
* Python

 Inside your script you will have access to predefined variables like request, response or exchange which will let you generate response.

== Switchyard - Camel CDI Integration
SwitchYard integrates the CDI Bean Manager with the Camel Bean Registry to allow you to reference CDI Beans in your Camel routes. Any Java class annotated with @Named in your application will be available through Camel's Bean registry.

[source,java]
----
@Named("StringSupport")
@ApplicationScoped
public class StringUtil {
 
    public String trim(String string) {
        return string.trim();
    }
}
----

[source,java]
----
public class ExampleBuilder extends RouteBuilder {
 
    public void configure() {
        from("switchyard://ExampleBuilder")
            .split(body(String.class).tokenize("\n"))
            .filter(body(String.class).startsWith("sally:"))
            .to("bean:StringSupport");
    }
}
----

See http://camel.apache.org/bean-binding.html[Camel's Bean Binding] documentation for more details.

== Switchyard - BPEL Component

 TODO: Create this

== Switchyard - BPM Component

 TODO: Create this

== Switchyard - Rules Component

 TODO: Create this

== Switchyard - Binding/Gateways
 ** Http based
 ***  SOAP
 ***  RESTEasy
 ***  HTTP
 ** Camel based
 *** JPA
 *** JCA
 *** JMS
 *** SQL
 *** File
 *** FTP FTPS SFTP
 *** TCP UDP
 *** Quartz
 *** Timer
 *** SEDA
 ** SCA
 ** Camel URI*
 ** MessageComposers/MessageContext
 ** Operation selection
 ** Throttling

== Switchyard - SOAP Binding

 TODO: Create this

=== SOAP Headers type

Header sent:

[source,xml]
----
<typ:amount xmlns:typ="http://ws.camelcookbook.org/payment-service/types">1000</typ:amount>
----

CONFIG:

[source,xml]
----
<typ:amount xmlns:typ="http://ws.camelcookbook.org/payment-service/types">1000</typ:amount>
----

DOM:
It is a DOM object. If you log it from Camel, it will print (cause it has data conversion) but internally it is not well converted.

[source,xml]
----
<typ:amount xmlns:typ="http://ws.camelcookbook.org/payment-service/types">1000</typ:amount>
----

Value:

[source,bash]
----
1000
----

XML: 

[source,xml]
----
<typ:amount xmlns:typ="http://ws.camelcookbook.org/payment-service/types">1000</typ:amount>
----
   
 TODO: What is the difference between CONFIG, DOM AND XML???


== Switchyard - RESTEasy Binding

 TODO: Create this

== Switchyard - HTTP Binding

 TODO: Create this

== Switchyard - JPA Binding

 TODO: Create this

== Switchyard - JCA Binding

 TODO: Create this

== Switchyard - JMS Binding

 TODO: Create this

- Where does #ConnectionFactory come from???
https://community.jboss.org/thread/243227
- use custom jndiPropertiesFile
- Use a .ra
- Configuration for tests with hornetq-jms.xml, hornetq-ra.xml, ...

== Switchyard - SQL Binding

 TODO: Create this

== Switchyard - File Binding

 TODO: Create this

== Switchyard - FTP FTPS SFTP Binding

 TODO: Create this

== Switchyard - TCP UDP Binding

 TODO: Create this

== Switchyard - Quartz Binding

 TODO: Create this

== Switchyard - Timer Binding

 TODO: Create this

== Switchyard - SEDA Binding

 TODO: Create this

== Switchyard - SCA Binding

 TODO: Create this

== Switchyard - Camel URI Binding

 TODO: Create this

== Switchyard - Message Composers
A MessageComposer can compose or decompose a native binding message to/from SwitchYard's canonical message.  A MessageComposer does this in three steps:

1. Construct a new target message instance.
2. Copy the content ("body") of the message.
3. Delegate the header/property mapping to a ContextMapper.

 We currently provide a SOAPMessageComposer, a CamelMessageComposer, and a HornetQMessageComposer.  These default implementations are used by their associated bindings, but can be overridden by the user.

 TODO: Check if more message composers exist (RESTeasyMessageCOmposer)

== Switchyard - Custom Message Composers

 TODO: Create this

== Switchyard - Context Mappers
A ContextMapper moves native binding message headers and/or properties to/from SwitchYard's canonical context.  

   Many ContextMapper implementations are provided OOTB).  These default implementations are used by their associated bindings, but can be overridden by the user.

* *SOAPContextMapper*: when processing an incoming SOAPMessage, takes the mime (in most cases, HTTP) headers from a soap envelope and maps them into the SwitchYard Context as Scope.MESSAGE properties with the SOAPComposition.SOAP_MESSAGE_MIME_HEADER label, and takes the soap header elements from the soap envelope and maps them into the SwitchYard Context as Scope.EXCHANGE properties with the SOAPComposition.SOAP_MESSAGE_HEADER label. When processing an outgoing SOAPMessage, it takes the SwitchYard Scope.OUT Context properties and maps them into mime (in most cases, HTTP) headers, and takes the SwitchYard Scope.EXCHANGE Context properties and maps them into the soap envelope as soap header elements.

* *CamelContextMapper*
* *HornetQContextMapper*
* *HTTPContextMapper*
* *RESTEasyContextMapper*
* *CCIIndexedRecordContextMapper*, *CCIMappedRecordContextMapper*, *JMSContextMapper* (JCA binding)

 TODO: Create this

== SwitchYard - Scopes

* Headers are scoped as MESSAGE. You will see some headers specifically useful for http requests, and other headers specifically useful for http responses.  In both cases, they are most likely tied to the binding's notion of an incoming message or an outgoing message.

* Properties are scoped as EXCHANGE, as this is most likely application or domain data, and possibly useful in the entire processing of the Exchange.

== Switchyard - Custom Context Mappers

 TODO: Create this


== Switchyard - Operation selection

 TODO: Create this

== Switchyard - Throttling

 TODO: Create this

== SwitchYard - Transformations (Java, JAXB, JSON, Smooks, XSLT, ...)

When is a transformation required:

 When origin type and destination type of a "wire connection" is not of the same type, and implicit type conversion (provided by Camel type converters) can not convert between both types.

 Declarative transformation only kicks in when the runtime detects that the message type is different between the consumer and provider contracts.

The tooling reflects this as well, which is why if there are no interactions where contract types differ, then you cannot create a transformer. There are three scenarios in SY where the contract types can differ and require a transformation:
 
1. A composite service interface is different from the component service interface it promotes.
2. A component reference interface is different from the component service interface it is wired to.
3. A composite reference interface is different from the component reference interface it promotes.

* Different implementations for transformations:
** Java
** JAXB
** JSON
** Smooks
** XSLT
** Transformations in a Camel component
** Other (coming next: Dozer,...)

== SwitchYard - Transformations - Content Type Names

Since transformations occur between named types (i.e. from type A, to type B), it's important to understand how the type names are derived. The type of the message is determined based on the service contract, which can be WSDL or Java.

For WSDL interfaces, the message name is determined based on the fully-qualified element name of a WSDL message.  Take the following WSDL definition:

[source,xml]
----
<definitions xmlns:tns="urn:switchyard-quickstart:bean-service:1.0">  
  <message name="submitOrder">
    <part name="parameters" element="tns:submitOrder"/>
  </message>
  <portType name="OrderService">
    <operation name="submitOrder">
      <input message="tns:submitOrder"/>
    </operation>
  </portType>
</definitions>
----

This would yield the following message type name based on the message element name defined in the WSDL:

[source,java]
----
{urn:switchyard-quickstart:bean-service:1.0}submitOrder
----

When Java interfaces are used for the service contract, the message name consists of the full package name + the class name, prefixed with "java:".

[source,java]
----
package org.switchyard.example;
public interface OrderService {
    void submitOrder(Order order);
}
----

The message type name for the submitOrder method in this Java interface would be *"java:org.switchyard.example.Order"*.  

Occasionally, it can be useful to override the default operation name generated for a Java interface. The *@OperationTypes* annotation provides this capability by allowing the user to specify the input, output, and/or fault type names used for a Java service interface. 

For example, if we wanted to accept XML input content without any need for transformation to a Java object model, the OrderService interface could be changed to look like this:

[source,java]
----
package org.switchyard.example;
public interface OrderService {
    @OperationTypes(in = "{urn:switchyard-quickstart:bean-service:1.0}submitOrder")
    void submitOrder(String orderXML);
}
----

Aside from short-circuiting the requirement for transformation, this annotation can be useful if you want to maintain tight control over the names used for message content.

== SwitchYard - Transformations

Required transformations are automatically detected by IDE, but, if missing, can be created/deleted/recreated manually:

image::switchyard/transformers/no_missing_transformer.png[All required validators have been added]

If you remove all/any of the transformers, you will be able to create missing required transformers:

image::switchyard/transformers/required_transformers.png[Create required transformer]

A new dialog will let you create a new transformer:

image::switchyard/transformers/new_transformer_all.png[New Transformer]

== SwitchYard - Transformations - Java
Java transformer let you do any kind of transformation using Java for this purpose. There are two methods available for creating a Java-based transformer in SwitchYard:

1. Implement the *org.switchyard.transform.Transfomer* interface and add a *<transform.java>* definition to your switchyard.xml.
2. Annotate one or more methods on your Java class with *@Transformer*.

 When using the @Transformer annotation, the SwitchYard maven plugin will automatically generate the <transform.java> definition(s) for you and add them to the switchyard.xml packaged in your application.

Implementing Java transformations is just a matter of creating a new (Java) Transformer on the SwitchYard application:

image::switchyard/transformers/new_transformer.png[New validator]

And selecting Java as the type of transformer you want implementing class or bean.

image::switchyard/transformers/new_java_transformer.png[Create a Java transformer]

It will create the appropiate transformer class/bean with the default annotated methods:

image::switchyard/transformers/java_transformer.png[Java Transformer class]

 The optional from and to elements of the @Transformer annotation can be used to specify the qualified type name used during transformer registration.  If not supplied, the full class name of the method parameter will be used as the from type and the full class name of the return type will be used as the to type.

And the corresponding configuration in the switchyard.xml file:

image::switchyard/transformers/transformer_switchyard_xml.png[Transformers defined in switchyard.xml file]

 The CDI bean name specified by @Named annotation is used to resolve transformer class. If you don't specify, then class name of the transformer is used instead.

== SwitchYard - Transformations - JAXB

The JAXB transformer allows you to perform Java to XML (and XML to Java) transformations using JAXB (XML marshalling and unmarshalling).

 JAXB Java models can be generated from an XML Schema using XJC, or from a WSDL using tools like wsconsume, or from within JBDS IDE with "JAXB`s JAXB classes from Schema" or "SwitchYard`s Java Files from WSDL".

JAXB Transformer requires a *to* and *from* with one Java type and one QNamed XML type, depending on whether you're performing a Java to XML or XML to Java transformation.

[source,java]
----
@XmlElementDecl(namespace = "http://com.acme/orders", name = "create")
public JAXBElement<CreateOrder> createOrder(CreateOrder value) {
    return new JAXBElement<Order>(_CreateOrder_QNAME, CreateOrder.class, null, value);
}
----

And the corresponding configuration in the switchyard.xml file:

image::switchyard/transformers/jaxb_transformer_switchyard_xml.png[JAXB transformers defined in switchyard.xml file]


== SwitchYard - Transformations - JSON

The JSON transformer provides a basic mapping facility between POJOs and JSON (JSON marshalling and unmarshalling). The JSON specification of the transformer requires a to and from specification with one Java type and one QNamed JSON type, depending on whether you're performing a Java to JSON or JSON to Java transformation.

[source,java]
----
<transforms>
   <xform:transform.json from="java:org.switchyard.quickstarts.transform.json.OrderAck" 
                         to="{urn:switchyard-quickstart:transform-json:1.0}orderResponse"/>
   <xform:transform.json from="{urn:switchyard-quickstart:transform-json:1.0}order" 
                         to="java:org.switchyard.quickstarts.transform.json.Order"/>
</transforms>
----

== SwitchYard - Transformations - Smooks

There are three distinct transformation models available with Smooks in SwitchYard:

1. XML to Java :  Based on a standard Smooks Java Binding configuration.
2. Java to XML:   Based on a standard Smooks Java Binding configuration.
3. Smooks :  This is a "normal" Smooks transformation in which the developer must define which Smooks filtering Result is to be exported back to the SwitchYard Message as the transformation result.

Smooks transformations are declared by including a <transform.smooks> definition in switchyard.xml.

[source,xml]
----
<transform.smooks config="/smooks/OrderAck_XML.xml"
                  from="java:org.switchyard.quickstarts.transform.smooks.OrderAck"
                  to="{urn:switchyard-quickstart:transform-smooks:1.0}submitOrderResponse"
                  type="JAVA2XML"/>
----
The config attribute points to a Smooks resource containing the mapping definition.  The type attribute can be one of SMOOKS, XML2JAVA, or JAVA2XML.

== SwitchYard - Transformations - XSLT

The XSLT transformer allows you to perform a transformation between 2 XML types, using an XSLT. It is configured simply by specifying the to and from QNames, as well as the path to the XSLT to be applied.

[source,xml]
----
<transforms>
   <transform.xslt xmlns="urn:switchyard-config:transform:1.0" 
                   from="{urn:switchyard-quickstart:transform-xslt:1.0}order" 
                   to="{urn:switchyard-quickstart:transform-xslt:1.0}orderAck" 
                   xsltFile="xslt/order.xslt"/>
</transforms>
----

And an xslt file is requierd for transformation:
[source,xml]
----
<?xml version="1.0"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	version="1.0">
	<xsl:template match="/">
		<orders:orderAck xmlns:orders="urn:switchyard-quickstart:transform-xslt:1.0">
			<xsl:for-each select="orders:order">
				<orderId>
					<xsl:value-of select="orderId" />
				</orderId>
				<accepted>
					<xsl:choose>
						<xsl:when test="(itemId = 'BUTTER') and (quantity &lt;= 200)">
							true
						</xsl:when>
						<xsl:otherwise>
							false
						</xsl:otherwise>
					</xsl:choose>
				</accepted>
				<status>
					<xsl:choose>
						<xsl:when test="(itemId = 'BUTTER') and (quantity &lt;= 200)">
							Order Accepted
						</xsl:when>
						<xsl:when test="itemId != 'BUTTER'">
							No Such Item:
							<xsl:value-of select="itemId" />
						</xsl:when>
						<xsl:when test="quantity &gt; 200">
							Not Enough Stock
						</xsl:when>
						<xsl:otherwise>
							UNKNOWN
						</xsl:otherwise>
					</xsl:choose>
				</status>
			</xsl:for-each>
		</orders:orderAck>
	</xsl:template>
</xsl:stylesheet>
----


== SwitchYard - Transformations - Transformations in a Camel component

Transformations can be done in Camel component. Camel provides with many means of doing tranformations: 

=== XSLT

[source,java]
----
   public void configure() throws Exception {
      from("direct:start")
            .to("xslt:book.xslt");
   }
----

==== XQuery

[source,java]
----
   public void configure() throws Exception {
      from("direct:start")
         .transform(xquery("<books>{for $x in /bookstore/book where $x/price>30 order by $x/title return $x/title}</books>"));
   }
----

=== JAXB

[source,java]
----
    public void configure() throws Exception {
        DataFormat myJaxb = new JaxbDataFormat("org.camelcookbook.transformation.myschema");

        from("direct:marshal")
            .marshal(myJaxb)
            .to("mock:marshalResult");

        from("direct:unmarshal")
            .unmarshal(myJaxb)
            .to("mock:unmarshalResult");
    }
----

=== JSON

[source,java]
----
    public void configure() throws Exception {
        from("direct:marshal")
            .marshal().json()
            .to("mock:marshalResult");

        from("direct:unmarshal")
            .unmarshal().json()
            .to("mock:unmarshalResult");
    }
----

=== XMLJSON

[source,java]
----
    public void configure() throws Exception {
        from("direct:marshal")
            .marshal().xmljson()
            .to("mock:marshalResult");

        from("direct:unmarshal")
            .unmarshal().xmljson()
            .to("mock:unmarshalResult");

        XmlJsonDataFormat xmlJsonFormat = new XmlJsonDataFormat();
        xmlJsonFormat.setRootName("bookstore");
        xmlJsonFormat.setElementName("book");
        xmlJsonFormat.setExpandableProperties(Arrays.asList("author", "author"));

        from("direct:unmarshalBookstore")
            .unmarshal(xmlJsonFormat)
            .to("mock:unmarshalBookstoreResult");
    }
----

See https://github.com/CamelCookbook/camel-cookbook-examples/tree/master/camel-cookbook-transformation[Camel developer cookbook Transformation Chapter source code]

== SwitchYard - Transformations - Transformations in a Camel component (II)
Transformations can be done in a variety of ways in camel:

[width="100%", cols="asciidoc,"]
|=======
|http://camel.apache.org/content-enricher.html[Content Enricher EIP] |image:transformers/ContentEnricher.gif[Content Enricher EIP]
|http://camel.apache.org/message-translator.html[Message Translator EIP] |image:transformers/MessageTranslator.gif[Message Translator EIP]
|http://camel.apache.org/content-filter.html[Content Filter EIP] |image:transformers/ContentFilter.gif[Content Filter EIP]
|http://camel.apache.org/normalizer.html[Normalizer EIP] |image:transformers/Normalizer.gif[Normalizer EIP]
|http://camel.apache.org/templating.html[Templating]|
|=======


== SwitchYard - Transformations - Other

 TODO: Create this

== SwitchYard - Validations (Java validations, XML Validation)
Validation feature provides a functionality for message content validation.

* Different implementations for validators:
** Java
** XML
** Other (to be coming...)

We often need to perform message validation before processing its data in service logic, but implementing the validation logic directly in the consumer or provider pollutes the service logic and can lead to tight coupling.  SwitchYard allows for the validation logic to be declared outside the service logic and injected into the mediation layer at runtime.

Validation of message content is specified in the descriptor of your SwitchYard application (switchyard.xml). The qualified name of the type being validated name is defined along with the validator implementation.

== SwitchYard - Java validations

Implementing Java validation is just a matter of creating a new (Java) Validator on the SwitchYard application:

image::switchyard/validators/new_validator.png[New validator]

And selecting type you want to validate and implementing class or bean.

image::switchyard/validators/java_validator.png[Create a Java validator]

It will create the appropiate configuration in the switchyard.xml file:

image::switchyard/validators/validator_switchyard_xml.png[Validator defined in switchyard.xml file]

And the appropiate class/bean needs to be created (manually), with the correspongin annotations (*@Named* and *@Validator*):

image::switchyard/validators/annotated_validator.png[Annotated validator]

Validation methods should return an instance of *import org.switchyard.validate.ValidationResult*.

There is a helper class for validation called: *org.switchyard.validate.BaseValidator* that provides with methods for *validResult()* and *invalidResult(...)*

== SwitchYard - XML validations

 TODO: Create this

== SwitchYard - Properties

 TODO: Create this

== SwitchYard - Environment Properties

Environment properties allow you to replace any attribute or element value in switchyard.xml with a property from the runtime environment. The syntax for a replaced token is "${varName}" where "varname" is your property name. The configuration layer in SwitchYard is configured with instances of PropertyResolver, which are used to resolve the value of a property based on its name.

=== Where to define Environment Properties
Property values are resolved from the following locations:

* System properties passed by -D option of Java VM like "-Dproperty.name=property.value"
* System environment variables, referenced with an "env." prefix, for example: env.PATH
* Unit test properties
* JBoss AS7 properties, including access into the SecurityVault
* Domain properties in switchyard.xml
* SCA property definitions in the composite or component

=== Property overriding
SwitchYard property resolver scans the property in following order.

* System properties and System environment variables
* Unit test properties
* JBoss AS7 properties
* Domain properties
* SCA composite properties
* SCA component properties

 You can specify the default property value with "${propertyName:defaultValue}" syntax where "propertyName" is the name of property.

=== Property escaping
Sometimes, the desired value for a property needs to be in the same "dollar curly" syntax which triggers SwitchYard's property substitution. This can be problematic because in these cases, you want SwitchYard to leave the configured value alone. To accomplish this, use a "double dollar curly" syntax instead.

[source,xml]
----
<foo value="${prop}"/>
<bar value="$${prop}"/>
----

Assuming the value "prop" is a resolvable property (say, equal to "test"), the value attribute of the foo element will be that value ("test").  However, the value attribute of the bar element will be "${test}" (with one dollar sign).

== SwitchYard - Implementation Properties
Implementation properties allow you to inject one or more property values into a service implementation.

This is based on the property support in the SCA assembly spec. Since the property is injected into service implementation logic, the injection mechanism itself is unique to each implementation type. 

* *Java*: injected using @Property into a CDI bean
* *Camel*: wired into Camel properties component and accessible in a Camel route using Camel's own varName property notation
* *BPEL*: mapped into process variables via an <assign> with using resolveProperty() XPath custom function
* *BPMN 2*: inserted into process variables by data input associations
* *Drools*: available in a global map

 TODO: Create this

== SwitchYard - Implementation Properties - Bean
Implementation properties represent environmental properties that you have defined in the SwitchYard application descriptor (switchyard.xml) for your bean implementation.  To access these properties, simply add an @Property annotation to your bean class identifying the property you want to inject. The following example demonstrates injection of a "user.name" property:

[source,java]
----
@Service(SimpleService.class)
public class SimpleServiceBean implements SimpleService {
 
   @Property(name="user.name")
   private String name;
 
   public String sayHello(String message) {
      return "Hello " + name + ", I got a message: " + message;
   }
}
----

== SwitchYard - Implementation Properties - Camel
SwitchYard integrates with the Properties Component in Camel to make system and application properties available inside your route definitions. You can inject properties into your camel route using "{{propertyName}}" expression where "propertyName" is the name of the property.

[source,xml]
----
<route xmlns="http://camel.apache.org/schema/spring" id="CamelTestRoute">
   <log message="ItemId [${body}]"/>
   <to uri="switchyard://WarehouseService?operationName=hasItem"/>
   <log message="Title Name [${body}]"/>
   <log message="Properties [{{user.name}}]"/>
</route>
----

== SwitchYard - Invocation Properties
It is information relative to the invocation or current execution. It is carried along the SwitchYard Context.

== SwitchYard - Invocation Properties - Bean Components
There can be situations where you need to access contextual information like message headers (e.g. received file name) in your implementation. To facilitate this, the Bean component allows you to access the SwitchYard Exchange Context instance associated with a given Bean Service Operation invocation. To get a reference to the Context, simply add a Context property to your bean and annotate it with the CDI @Inject annotation.

[source,java]
----
@Service(SimpleService.class)
public class SimpleServiceBean implements SimpleService {
 
@Inject
private Context context;
 
public String sayHello(String message) {
        System.out.println("*** Funky Context Property Value: " + context.getPropertyValue("funkyContextProperty"));
        return "Hi there!!";
    }
}
----

 The Context interface allows your bean logic to get and set properties in the context.  Note that you can only make calls on the Context instance within the scope of one of the Service Operation methods. Invoking it outside this scope will result in an UnsupportedOperationException being thrown.

== SwitchYard - Policies (transaction, )
Policy allows you to control the runtime behavior of a service in a declarative manner, independent of the service implementation and binding details. 

* Configuring policy
* Interaction Policy
* Implementation Policy

 TODO: Create this

== Transaction Policy

 TODO: Create this

== Transaction Interaction Policy

 TODO: Create this

== Transaction Implementation Policy

 TODO: Create this

== Security Policy

 TODO: Create this

== Security Interaction Policy

 TODO: Create this

== Security Implementation Policy

 TODO: Create this

== SwitchYard - Security
SwitchYard services can be secured by:

1. Specifying a list of security policies that are required for that service.
2. Configuring application-level security processing details for the services within a domain.
3. Configuring system-level security processing details.
4. Storing sensitive information, such as passwords, in the JBoss AS password vault.

 TODO: Create this

== SwitchYard - Clustering
There are two fundamental building blocks to the clustering support in SwitchYard:

* *Shared Runtime Registry*: a shared, distributed runtime registry which allows individual instances to publish and query service endpoint details.
* *Remote Communication Channels*: an internal communication protocol used to allow a service client to invoke a service hosted in a remote instance.

image::switchyard/clustering.jpg[Clustering]

The runtime registry is backed by a replicated Infinispan cache.  Each instance in a cluster points to the same replicated cache.  When a node joins a cluster, it immediately has access to all remote service endpoints published in the registry.  If a node leaves the cluster due to failure or shutdown, all service endpoint registrations are immediately removed for that node.  The registry is not persisted, so manually clean-up and maintenance is not required.  Note that the shared registry is a runtime registry and not a publication registry, which means the registry's lifecycle and state is tied to the current state of deployed services within a cluster.  This is in contrast to a publication registry (e.g. UDDI), where published endpoints are independent from the runtime state of the ESB.

The communications channel is a private intra-cluster protocol used by instances to invoke a remote service.  The channel is currently based on HTTP, but this may change in the future and should be considered a transparent detail of the clustering support in SwitchYard.

 TODO: REVIEW this

== SwitchYard - Configuring Clustering
Clustering support is light on configuration and should work out of the box.  The only real requirements are using a shared Infinispan cache for the runtime registry and indicating which services are clustered in your application config (switchyard.xml).  By default, SwitchYard uses the default cache in the "cluster" cache container which comes pre-defined in your standalone-ha.xml.  Unless you have specific requirements to use a different cache or separate cache configuration, just stick with the default.

Applications take advantage of clustering by explicitly identifying which services should be clustered in the application's descriptor (switchyard.xml).  You can control which services in your application will be published in the cluster's runtime registry and which references can be resolved by clustered services.  To enable a service to be published in the cluster's runtime registry, promote the service in your application and add a <binding.sca> with clustering enabled to it.

[source,xml]
----
<sca:service name="Goodbye" promote="GoodbyeBean/Goodbye">   
   <sca:interface.java interface="com.example.Goodbye"/>
   <sca:binding.sca sy:clustered="true"/>
</sca:service>
----

Consuming services in a cluster follows the same configuration approach, but applies to references in your application.  To invoke a service in a cluster, promote the reference and add an SCA binding with clustering enabled.

[source,xml]
----
<sca:reference name="Goodbye" multiplicity="0..1" promote="GreetingBean/Goodbye">
   <sca:interface.java interface="com.example.Goodbye"/>
   <sca:binding.sca sy:clustered="true"
</sca:reference>
----

 TODO: REVIEW this

== SwitchYard - Using Clustering
To create a cluster of SwitchYard instances, start two or more AS 7 instances with a shared Infinispan cache.  Out-of-the-box configuration in standalone-ha.xml should be sufficient:

[source,bash]
----
# start instance 1
node1> bin/standalone.sh -c standalone-ha.xml -Djboss.node.name=node1
# start instance 2
node2> bin/standalone.sh -c standalone-ha.xml -Djboss.node.name=node2 -Djboss.socket.binding.port-offset=1000
----

Once the instances are up, you can deploy applications independently to each instance.  A homogeneous cluster would have identical applications deployed on each node.  A heterogeneous cluster will have different applications and services deployed on each instance. For testing purposes, it's easiest to deploy a consumer application to one instance and a provider application to another.

 TODO: REVIEW this

== SwitchYard - RemoteInvoker

 TODO: Create this

== SwitchYard - Serialization

 TODO: Create this

== SwitchYard - Extensions

 TODO: Create this

== SwitchYard - Use cases:
 * Asynchronous processing: How to build, deploy, and manage a simple Camel route that communicates with ActiveMQ queues
 * Synchronous processing: How to build, deploy, and manage a simple service

 TODO: Create this

== SwitchYard - Debugging an application
 * Message tracing
 * Exchange interceptors
 * Auditing exchanges

 TODO: Create this

== SwitchYard - Testing SwitchYard application
Switchyard testing capabilities rely on JUnit4.

* SwitchYardRunner
* SwitchYardTestKit
* SwitchYardTestCaseConfig

 TODO: Create this

== SwitchYard - Testing - SwitchYardRunner

 TODO: Create this

== SwitchYard - Testing - SwitchYardTestKit

 TODO: Create this

== SwitchYard - Testing - SwitchYardTestCaseConfig

* config
* mixins
* scanner

 TODO: Create this

== SwitchYard - Testing - MixIns

* CDIMixIn
* HTTPMixIn
* SmooksMixIn
* HornetQMixIn
* JCAMixIn
* NamingMixIn
* PropertyMixIn
 
 TODO: Create this

== SwitchYard - Testing - Scanners

* *BeanSwitchYardScanner*: Scans for CDI Bean Service implementations.
* *TransformSwitchYardScanner*: Scans for Transformers.
* *BpmSwitchYardScanner*: Scans for @Process, @StartProcess, @SignalEvent and @AbortProcessInstance annotations.
* *RouteScanner*: Scans for Camel Routes.
* *RulesSwitchYardScanner*: Scans for @Rule annotations.
  
 TODO: Create this

== SwitchYard - Testing - Metadata and support injection
  
* TestKit Injection
* Deployment Injection
* SwitchYardModel Injection
* ServiceDomain Injection
* TransformerRegistry Injection
* TestMixIn Injection
* PropertyMixIn Injection
* Invoker Injection
 TODO: Create this

== SwitchYard - Advanced topics
 * Creating your own camel endpoint/component (Extensions)
 * Distributed transactions in FSW - what is possible and what is not possible (e.g. can a splitter/aggregator ever be transactional)

 TODO: Create this

== RTGov

For call trace
* ActivityReporter: reports activity to the BAM server. Can be injected with @Inject in a Bean Component. (How can be injected in Camel or any other???) Has methods logError, logWarn, logInfo,...

For policies:
* AbstractExchangeValidator extends ExchangeInterceptor: This class observes exchanges and uses the information to create activity events to be validated
* ExchangeInterceptors allow code to be injected around specific interactions in the core exchange bus via a target definition. Valid targets are documented as constant fields in this interface

InformationProcessor that is based on a set of expressions used to extract relevant data from the supplied information.

 TODO: Create this


== DTGov

 * App building
 * life-cycle management
 * Deployment
 * Integrating the build/test/deployment process into a maven based build engine

 TODO: Create this

== Development
 
 * JBoss Developer Studio + IS plugins
 * Maven
 * Project structure (single project, multiproject, war, ear,...)

 TODO: Create this


== Operations
 
 * Installation (installer, silent,...)
 * Starting/stopping servers (server services)
 * Users
 * Multinode configuration (Multiple servers in one box
 * Databases
 * Management (Console, CLI, JMX, BPEL Console)
 * Monitoring
 * Troubleshooting

 TODO: Create this

== Thank you

That's all.

