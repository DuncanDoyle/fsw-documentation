FSW Training
============
:author: Jorge Morales 
:email: <jmorales@redhat.com>
:description: FSW training
:revdate: 2014-07-17
:revnumber: 0.1
:icons: font
:imagesdir: ./images
:figure-caption!:
:deckjs_theme: beamer
// web-2.0
//:deckjs_transition: horizontal-slide
//:pygments:
//:pygments_style: native
:scrollable:
// :linkcss: ./css/redhat.css
//:count_nested:

== FSW from the Red Hat website

[quote, Red Hat website, http://www.redhat.com/es/technologies/jboss-middleware/fuse-service-works]
____
Red Hat® JBoss® Fuse Service Works is a platform that creates reusable, changeable, and flexible business services that hide the complexity of connecting to different applications in your enterprise. It sets the stage for faster and easier cloud apps, mobile apps, and business process development projects.

JBoss Fuse Service Works combines technical innovations from leading open source projects with the experience and support you expect from a world-class software provider.

image::fsw/FSW_benefits.png[FSW benefits]
____

== FSW from the JBoss.org

[quote, JBoss.org, http://www.jboss.org/products/fsw/overview/]
____
An open source service design, development and integration platform that speeds up cloud integration.

JBoss Fuse Service Works is Red Hat’s middleware solution for application integration, messaging, SOA, and service governance requirements. It combines the core ESB technology from JBoss Fuse and technical innovations from popular open source communities like SwitchYard and Overlord.
____

== From the official documentation

[quote, Red Hat product documentation, https://access.redhat.com/documentation/en-US/Red_Hat_JBoss_Fuse_Service_Works/6/html/User_Guide/chap-Preface.html]
____
Red Hat JBoss Fuse Service Works is a platform for developing enterprise application integration (EAI) and service-oriented architecture (SOA) solutions. It consists of a service component framework, business rules/complex event processing, life-cycle governance, runtime governance and process automation. It is built on the same core as JBoss Fuse with enterprise messaging, Camel and CXF so, therefore, users can use it to design, deploy, integrate and orchestrate business services.
____


== FSW Core Capabilities
The benefits of using Red Hat JBoss Fuse Service Works include the following:

Enterprise Integration Pattern (EIP) Based Development:: The versatile EIP framework is implemented in routing and transformation processes for faster and more efficient integration solutions.
High Performance Messaging:: A high performance messaging broker supports messaging patterns such as publish-subscribe, point-to-point and store-forward, and multiple cross language clients.
Service Development:: The web services framework exposes integration assets as services and calls external services, supporting all major web services standards. It also supports RESTful calls.
Structured Service Development:: A lightweight service development framework provides full lifecycle support for developing, deploying, and managing service-based applications.
Automatable Registry with Workflow:: Manage the lifecycle of services from design, development and deployment by defining, exposing and enforcing rules or policies.
Business Transaction Monitoring:: Capture service activity information, define and collect metrics, and define alerts and SLAs.
Report a bug:: (Just kidding)

=== FSW as System Integration
Integrating your major business systems into a cohesive infrastructure can be a challenge, especially when you have legacy applications. Red Hat JBoss Fuse Service Works has a number of ways enable you to integrate both new and legacy applications. Development is simplified with a transparent, lightweight service framework which uses EIP technology. This allows developers to focus on higher order concepts while still working with familiar technologies such as Apache Camel, BPEL, BPMN or POJOs. To reduce the operational costs of production and maintenance, the platform utilizes automatable, content-aware repository and service activity monitoring. These support the entire service lifecycle and development, QA and production teams with run-time and design-time visibility, monitoring and alerting.

== What is integration

[quote, Wikipedia, http://en.wikipedia.org/wiki/Systems_integration]
____
System integration is defined as the process of bringing together the component subsystems into one system and ensuring that the subsystems function together as a system.

The system integrator brings together discrete systems utilizing a variety of techniques such as computer networking, enterprise application integration, business process management or manual programming.
____

== What is applications integration

[quote, MuleSoft, https://www.mulesoft.com/resources/esb/applications-integration]
____
Applications integration (or enterprise application integration) is the sharing of processes and data among different applications in an enterprise. For both small and large organizations alike, it has become a mission-critical priority to connect disparate applications and leverage application collaboration across the enterprise in order to improve overall business efficiency, enhance scalability, and reduce IT costs.
____

== What is governance

[quote, Wikipedia, http://en.wikipedia.org/wiki/Governance]
____
Governance refers to "all processes of governing, whether undertaken by a government, market or network, whether over a family, tribe, formal or informal organization or territory and whether through laws, norms, power or language." It relates to processes and decisions that seek to define actions, grant power and verify performance.
____

== Training contents

* SwitchYard
* RTGov
* DTGov

== FSW Overview - Components

image:fsw/fsw_component_overview.png[FSW component overview]

== FSW Overview - Layers

image:fsw/fsw_layers.png[FSW layers]

== FSW Overview - Architecture 

image:fsw/fsw_architecture.png[FSW architecture]

== SwitchYard

image::switchyard/switchyard.png[] 

* SCA (Service, component, reference, binding)
* Components (Service implementations)
* Bindings (Gateways)
* Transformations (Java, JAXB, JSON, Smooks, XSLT, ...)
* Validations (Java validations, XML Validation)
* Properties
* Policies (transaction, )
* Security
* Clustering
* RemoteInvoker
* Serialization
* Extensions 

== SwitchYard - SCA

____
SwitchYard is a component-based *development framework* focused on building *structured*, *maintainable services* and *applications* using the concepts and best practices of SOA. It works with Apache Camel to provide a *fast*, *simple*, *flexible* integration runtime with *comprehensive* connectivity and transports. A *uniform* application model *augments* Apache Camel, *joining* Java EE, BPM, rules, orchestration, and routing into a *cohesive* development model and runtime. 

Common functionality and cross-cutting concerns - validation, transformation and policy - are isolated from business logic and handled declaratively. This ensures *consistency* and *eliminates duplication*, offering developers a clear view of the structure and relationships of services in an integration application.
____

== SwitchYard - SCA

image::switchyard/sca/app.jpg[SwitchYard application]

== Composite
A composite is displayed as a light blue rectangle and represents the boundary between what's inside your application and what's outside your application. A SwitchYard application consists of exactly one composite that has a name and a targetNamespace. The targetNamespace value is important as it allows names defined locally in the application (e.g. service names) to be qualified and unique within a SwitchYard runtime.

== Composite
image::switchyard/sca/composite.jpg[composite]

[source,xml]
----
<sca:composite name="example" targetNamespace="urn:example:switchyard:1.0">
</sca:composite>
----

== Component
A component is a modular container for application logic and consists of the following:

* 0 or 1 component service definitions
* 0 to many component reference definitions
* 1 implementation

Services and references allow a component to interact with other components, while the implementation provides the actual logic for providing and/or consuming services.

== Component
image::switchyard/sca/component.jpg[component]

[source,xml]
----
<sca:component name="Routing">
</sca:component>
----

== Implementation
An implementation acts as the 'brain' of a service component and it is how implement your application logic. The following implementation options are available:

* *Bean*: allows a CDI Bean to consume or provide services using annotations.
* *Camel*: EIP-style routing and service composition using the XML or Java DSL in Apache Camel.
* *BPMN 2*: service orchestration and human task integration expressed as BPMN 2 and executed using jBPM.
* *BPEL Process*: web service orchestration using the OASIS Business Process Execution Language.
* *Rules*: decision services based on Drools.

Implementations are private to a component, which means external consumers and providers are not aware of the details of a component's implementation (implementation-hiding).  All interactions with other components within an application and with external services are handled through component services and references.

== Implementation
image::switchyard/sca/implementations.jpg[implementation]

[source,xml]
----
<sca:component name="Routing">
   <camel:implementation.camel>
      <camel:xml path="RoutingService.xml"/>
   </camel:implementation.camel>
</sca:component>
----

== Component Service
A component service is used to expose the functionality of an implementation as a service. All component services have a contract, which can be a Java interface, WSDL portType definition, or a set of named data types (interface.esb). Component services are private to an application, which means a component service can only be invoked by other components in the same application. In order to expose a component service to consumers external to the application, a component service can be 'promoted' to a composite service. A component service can be promoted multiple times to create different composite services.

== Component Service
image::switchyard/sca/component-service.jpg[Component service]

[source,xml]
----
<sca:component name="Routing">
   <camel:implementation.camel>
      <camel:xml path="route.xml"/>
   </camel:implementation.camel>
   <sca:service name="ServiceA">
      <sca:interface.java interface="org.example.ServiceA"/>
   </sca:service>
</sca:component>
----

== Composite Service
A composite service represents an application service which is visible to other applications. A composite service can only be realized by promoting a component service within the application. The name and the interface of the composite service can be different from the component service. If the interface, or contract, of the composite service is different from the component service, be aware that a transformation may be required to map between the types defined in each interface. In our example application, the component service has a Java interface while the composite service has a WSDL interface. This means we would need to declare a transformer which maps between XML and Java to resolve the data type mismatch.

== Composite Service
image::switchyard/sca/composite-service.jpg[Composite service]

[source,xml]
----
<sca:composite name="example" targetNamespace="urn:example:switchyard:1.0">
   <sca:service name="ServiceA" promote="Routing/ServiceA">
      <sca:interface.wsdl interface="ServiceA.wsdl#wsdl.porttype(ServiceAPortType)"/>
   </sca:service>
</sca:composite>
----

== Service Binding
A service binding is used to define an access method for a composite service. Composite services can have multiple bindings, which allows a single service to be accessed in different ways. In most cases, a service binding represents a protocol/transport adapter (e.g. SOAP, JMS, REST). An important exception to this rule is the SCA binding, which allows services across applications in the same runtime to be wired together in memory. Regardless of the underlying binding details, a binding must always be used to facilitate inter-application communication in SwitchYard.

== Service Binding
image::switchyard/sca/service-binding.jpg[Service binding]

[source,xml]
----
<sca:composite name="example" targetNamespace="urn:example:switchyard:1.0">
   <sca:service name="ServiceA" promote="Routing/ServiceA">
      <sca:interface.wsdl interface="ServiceA.wsdl#wsdl.porttype(ServiceAPortType)"/>
      <soap:binding.soap>
        <soap:wsdl>ServiceA.wsdl</soap:wsdl>
      </soap:binding.soap>
   </sca:service>
</sca:composite>
----

== Component Reference
A component reference allows a component to consume other services. A component reference can be wired to a service offered by another component in the same application or it can be wired to services outside the application via a composite reference. Similar to component services, all component references have a contract with allows a component to invoke services without knowing implementation or binding details. The picture below shows an example of wiring a reference on the Routing component to a service offered by the Bean component.

== Component Reference
image::switchyard/sca/component-reference.jpg[Component reference]

[source,xml]
----
<sca:component name="Routing">
   <camel:implementation.camel>
      <camel:xml path="route.xml"/>
   </camel:implementation.camel>
   <sca:service name="ServiceA">
      <sca:interface.java interface="org.example.ServiceA"/>
   </sca:service>
   <sca:reference name="ServiceC">
      <sca:interface.java interface="org.example.ServiceC"/>
   </sca:reference>
</sca:component>
----

== Composite Reference
A composite reference allows a component reference to be wired to a service outside the application. Similar to composite services, bindings are used with composite references to specify the communication method for invoking the external service.

== Composite Reference
image::switchyard/sca/composite-reference.jpg[Composite reference]

[source,xml]
----
<sca:composite name="example" targetNamespace="urn:example:switchyard:1.0">
   <sca:reference name="ReferenceB" multiplicity="0..1" promote="Routing/ServiceB">
      <sca:interface.java interface="org.example.ServiceB"/>
   </sca:reference>
</sca:composite>
----

== Reference Bindings
A reference binding is used to define an access method for an external service via a composite reference. Unlike service bindings, there can only be one binding for each composite reference. The set of bindings available for references is identical to the set of bindings available for services, although the configuration values for a given binding may be different depending on whether it's used as a service binding or a reference binding.

== Reference Bindings
image::switchyard/sca/reference-binding.jpg[Reference binding]

[source,xml]
----
<sca:composite name="example" targetNamespace="urn:example:switchyard:1.0">
   <sca:reference name="ReferenceB" multiplicity="0..1" promote="Routing/ServiceB">
      <sca:interface.java interface="org.example.ServiceB"/>
         <jms:binding.jms>
         <jms:queue>MyQueue</jms:queue>
         <jms:connectionFactory>#ConnectionFactory</jms:connectionFactory>
      </jms:binding.jms>
   </sca:reference>
</sca:composite>
----

== SCA terms summary

image::switchyard/sca/sca_summary.png[SCA Summary]

== Create an application

image::switchyard/service_creation/1.png[To create this service]

== Create a composite

image::switchyard/service_creation/2.png[Create a composite]

== Add a component

image::switchyard/service_creation/3.png[Add a component]

== Add more components and link them

image::switchyard/service_creation/4.png[Add more components and link them]

== Even more components

image::switchyard/service_creation/5.png[Even more components]

== Expose/call your service

image::switchyard/service_creation/6.png[Expose/call your service]

== Invoke/Call external applications (references)

image::switchyard/service_creation/1.png[Call external applications]

== Configure every declarative aspect

* Properties
* Policies
* Transformations
* Validation
* ...

== Components - What we have
 **  Component contract interfaces: wsdl, java, esb
 **  Bean (Java)
 **  Camel (java, xml)
 **  BPEL (XPath functions)
 **  BPM
 **  Rules (Knowledge services)

== Contracts

Every service needs to have it's contract defined (API).

This contracts can be defined in on of 3 ways:

* Java 
* WSDL
* SOA

NOTE: SwitcyYard require a one parameter per method in the contract definition

== Java contract

.Definition
image::switchyard/contracts/java_contract.png[Java contract]

.Implementation
image::switchyard/contracts/java_contract_impl.png[Java contract Implementation]

== WSDL contract

.Definition
image::switchyard/contracts/wsdl_contract.png[WSDL contract]

.Implementation
image::switchyard/contracts/wsdl_contract_impl.png[WSDL contract Implementation]

== ESB contract

.Definition and implementation
image::switchyard/contracts/esb_contract.png[ESB contract]

== Bean Component
The Bean Component is a pluggable container in SwitchYard which allows Java classes (or beans) to provide and consume services. This means that you can implement a service by simply annotating a Java class. It also means you can consume a service by injecting a reference to that service directly into your Java class

image::switchyard/components/bean/bean_component.png[Bean component]

== Creating a Bean service
To create a new Bean service you only need a few pieces of information:

* *Name*: the name of the Java class for your bean service.
* *Service Name*: the name of the service your bean will provide.
* *Interface*: the contract for the service being provided.  Java is the only valid interface type for bean services.

== Creating a Bean service
image::switchyard/components/bean/new-bean.jpg[New bean component]

== Creating a Bean service

[source,java]
----
package com.example.switchyard.docs;
 
import org.switchyard.component.bean.Service;
 
@Service(Example.class)
public class ExampleBean implements Example {
 
}
----

The @Service annotation allows the SwitchYard CDI Extension to discover your bean at runtime and register it as a service. The value of the annotatio represents the service contract for the service. 

 Every bean service must have an @Service annotation with a value identifying the service interface for the service.
 
== Consuming a Bean service
In addition to providing a service in SwitchYard, beans can also consume other services. These services can be provided in the same application by other implementations, or they could be wired to gateway bindings to invoke services over JMS, SOAP, FTP, etc. The SwitchYard runtime handles the resolution of the service reference to a concrete service, allowing your service logic to remain blissfully ignorant. Invocations made through this reference are routed through the SwitchYard exchange mechanism.

[source,java]
----
@Inject @Reference
private SimpleService service;

public void consumeSomeService(String consumerName) {
   service.sayHello("Hello " + consumerName);
}
----

== Consuming a Bean service
By default, SwitchYard expects a service reference to be declared with a name which matches the Java type used for the reference. In the event where the service reference name is different from the type name of the contract, the @Reference annotation can accept a service name

[source,java]
----
@Inject @Reference("urn:com.example.services:SimpleService:1.0")
private SimpleService service;

public void consumeSomeService(String consumerName) {
   service.sayHello("Hello " + consumerName);
}
----

== Consuming a Bean service

image::switchyard/components/bean/consume_service_1.png[]

== Consuming a Bean service

image::switchyard/components/bean/consume_service_2.png[]

== Consuming a Bean service

image::switchyard/components/bean/consume_service_3.png[]

== Consuming a Bean service

image::switchyard/components/bean/consume_service_4.png[]

== Reference Invoker
The default behavior of @Reference is to inject a reference using the Java interface of the reference contract. This is adequate for most cases, but it does not allow you to access SwitchYard API constructs like the Message and Context interfaces. 

If you need to access to an attachment or a context property when invoking a reference from a Bean service, then you will want to use a *ReferenceInvoker*. To use a ReferenceInvoker, all you need to do is _replace the service contract interface type with a ReferenceInvoker type and SwitchYard will automatically inject the correct instance_.

[source,java]
----
@Inject @Reference("urn:com.example.services:SimpleService:1.0")
private ReferenceInvoker service;

public void consumeSomeService(String consumerName) {
   service.newInvocation("sayHello")
      .setProperty("myHeader", "myValue")
      .invoke(consumerName);
}
----

 Note how the ReferenceInvoker instance is used to create a ReferenceInvocation using the newInvocation() method. A new instance of ReferenceInvocation should be created each time you want to invoke a service using ReferenceInvoker.

== Camel Component
Camel services allow you to leverage the core routing engine inside of Apache Camel to route between services in SwitchYard. All of the EIP and core routing support in Camel is available to your service implementation. Each Camel route is exposed as a service within SwitchYard, which means it has a well-defined contract and can be injected into any other service in the runtime.

There are 2 implementations:

* Java DSL
* XML DSL

== Camel Component Tips

* There is only one route per service. (More routes can be created, only one component entry point)
* The consumer or "from" endpoint in a route is always a "switchyard" endpoint and the endpoint name must equal the service name.  This is default behavior in the tooling.
* To consume other services from within your route, only use "switchyard" consumer (i.e. "to") endpoints. This keeps your routing logic independent of the binding details for consumed services.

 These are tips and behaviour can be modify to NOT comply with above tips 

== Creating a Camel Service in Java DSL

image::switchyard/components/camel/new_camel_java_service.png[New Camel Java Service]

== Creating a Camel Service in Java DSL

[source,java]
----
package com.example.switchyard.docs;
 
import org.apache.camel.builder.RouteBuilder;
 
public class CamelServiceRoute extends RouteBuilder {
    /**
     * The Camel route is configured via this method.  The from:
     * endpoint is required to be a SwitchYard service.
     */
    public void configure() {
        // TODO Auto-generated method stub
        from("switchyard://Example").log(
                "Received message for 'Example' : ${body}");
    }
}
----

 There are no SwitchYard-specific classes or APIs used for Java DSL route; the route class is identical in signature to what you would use with Apache Camel directly.

== Creating a Camel Service in XML DSL

image::switchyard/components/camel/new_camel_xml_service.png[New Camel XML Service]

== Creating a Camel Service in XML DSL

[source,xml]
----
<?xml version="1.0" encoding="ASCII"?>
<route xmlns="http://camel.apache.org/schema/spring">
   <from uri="switchyard://Example"/>
   <log message="Example - message received: ${body}"/>
</route>
----

 The XML routing syntax is identical to what you would use with Apache Camel directly and conforms to the Camel schema for <route> definition

== Drawbacks in Camel Service in XML DSL

NOTE: As of FSW 6.0 there is no access to Camel Context from within the route xml definition file, so it is not suitable for defining namespaces,... or anything that get's registered into the Camel Context.

== Consuming services from Camel routes
Invoking another service from within your Camel route can be done by using the SwitchYard producer endpoint (switchyard://) within your route.  Endpoint configuration is very straightforward:

[source,java]
----
switchyard://<service-name>[?operationName=<operation-name>]
----

* *service-name*: name of the SwitchYard service. This value needs to match the name of a service reference defined on the service component for the route.
* *operation-name*: name of the service operation to be invoked. This is only used on references and is optional if the target service only has a single operation.

image::switchyard/composite_overview.png[Composite overview]

== Scripting languages in Camel
Because of 3rd party dependencies, SwitchYard supports only following languages:

* BeanShell
* JavaScript
* Groovy
* Ruby
* Python

 Inside your script you will have access to predefined variables like request, response or exchange which will let you generate response.

[source,java]
----
public class ScriptingBuilder extends RouteBuilder {
 
    public void configure() {
        from("switchyard://Inbound")
            .filter().javaScript("request.getHeader('myHeader') != null")
                .to("switchyard://Outbound");
    }
}
----

[source,java]
----
public class ScriptingImplementationBuilder extends RouteBuilder {
 
    public void configure() {
        from("switchyard://Inbound")
            .transform().groovy("classpath:script.groovy"); // classpath resource
 
        from("switchyard://InboundBsh")
            .transform().language("beanshell", "file:script.bsh"); // file system resource
    }
}
----

== Camel CDI Integration

SwitchYard integrates the CDI Bean Manager with the Camel Bean Registry to allow you to reference CDI Beans in your Camel routes. Any Java class annotated with @Named in your application will be available through Camel's Bean registry.

[source,java]
----
@Named("StringSupport")
@ApplicationScoped
public class StringUtil {
 
    public String trim(String string) {
        return string.trim();
    }
}
----

[source,java]
----
public class ExampleBuilder extends RouteBuilder {
 
    public void configure() {
        from("switchyard://ExampleBuilder")
            .split(body(String.class).tokenize("\n"))
            .filter(body(String.class).startsWith("sally:"))
            .to("bean:StringSupport");
    }
}
----

See http://camel.apache.org/bean-binding.html[Camel's Bean Binding] documentation for more details.

== Create a BPEL Component service
Once you have your WSDL interface for the BPEL service, add the component to the SwitchYard configuration (create or define the implementation and service interface).

image::switchyard/components/bpel/new_bpel_service_1.png[New BPEL service]

image::switchyard/components/bpel/new_bpel_service_2.png[New BPEL service]

Whis will create the appropiate partnerLinks definitions.

image::switchyard/components/bpel/new_bpel_service_3.png[New BPEL service]

== Create a BPEL Component service
The created BPEL component contains a single 'implementation.bpel' element that identifies the fully qualified name of the BPEL process.

[source, java]
----
<sca:component name="Process">
   <sca:implementation.bpel process="process:Process"/>
   <sca:service name="Payment">
      <sca:interface.wsdl interface="META-INF/paymentService.wsdl#wsdl.porttype(Payment)"/>
   </sca:service>
</sca:component>
----

The component may also contain one or more service elements defining the WSDL port types through which the BPEL process can be accessed.

== Create a BPEL Component service
Define your process using WS-BPEL (e.g. using the Eclipse BPEL editor bundled with JBossTools).

image::switchyard/components/bpel/new_bpel_service_4.png[New BPEL service]

== Create a BPEL Component service
Define a Deployment Descriptor (/deploy.xml) using the ODE Deployment Descriptor editor bundled with JBossTools.

image::switchyard/components/bpel/new_bpel_service_5.png[New BPEL service]

== BPEL Component consuming a service

image::switchyard/components/bpel/invoke_service_from_bpel_1.png[Invoke BPEL service]

The first step is to define the WSDL interface(s), representing the service(s) to be consumed, using an invoke element within the deployment descriptor

[source,java]
----
<process name="ls:loanApprovalProcess">
        <active>true</active>
        <process-events generate="all"/>
        <provide partnerLink="customer">
            <service name="ls:loanService" port="loanService_Port"/>
        </provide>
        <invoke partnerLink="assessor" usePeer2Peer="false">
            <service name="ra:riskAssessor" port="riskAssessor_Port"/>
        </invoke>
    </process>
----

NOTE: The 'usePeer2Peer' property informs the BPEL engine not to use internal communications for sending messages between BPEL processes that may be executing within the same engine, and instead pass messages through the SwitchYard infrastructure.

For each consumed service, we then need to create a reference element within the SwitchYard configuration, to locate the WSDL file and identify the port type associated with the required WSDL service/port.

[source,java]
----
<sca:component name="loanService">
   <bpel:implementation.bpel process="ls:loanApprovalProcess" />
   <sca:service name="loanService">
      <sca:interface.wsdl interface="loanServicePT.wsdl#wsdl.porttype(loanServicePT)"/>
   </sca:service>
   <sca:reference name="riskAssessor" >
      <sca:interface.wsdl interface="riskAssessmentPT.wsdl#wsdl.porttype(riskAssessmentPT)"/>
   </sca:reference>
</sca:component>
----

== Structure of a BPEL application

image::switchyard/components/bpel/switchyard-BPEL-structure.png[BPEL application]

NOTE: The important part is how the artifacts are structured within the src/main/resources folder.

* The switchyard.xml configuration file is located in the META-INF folder as usual. However the BPEL deployment descriptor (deploy.xml), and the BPEL process definition are located in the root folder.
* The WSDL interface definitions, and any accompanying XSD schemas, can be located in sub-folders. If they are, then the BPEL process and SwitchYard BPEL component configuration must define the correct relative path.

== BPEL Component TIPS

* Avoid usage of BPEL components if possible

== Knowledge Services

* BPM component
* Rules component

Both BPM and Rules share the same execution engine, and share some common configurations

== BPM Component
To create a new BPM service in SwitchYard, you'll need the following information:

* File Name: the file name that will be used to create a new, empty BPMN 2 Process definition.
* Interface Type: the contract for the service being provided.  BPM supports Java, WSDL, and ESB contract types.
* Service Name: the name of the service your process will provide.

image::switchyard/components/bpm/new_bpm_service_1.png["New BPM component"]

image::switchyard/components/bpm/new_bpm_service_2.png["New BPM component"]

== Process interaction
Interaction with a process is defined via actions on a BPM service component.

[source,java]
----
package org.switchyard.userguide;
public interface MyService {
    public void start(String data);
    public void signal(String data);
    public void abort(String data);
}
----

Actions allow you to map an operation in the service contract to one of the following interactions with a business process:

----
START_PROCESS
SIGNAL_EVENT
SIGNAL_EVENT_ALL
ABORT_PROCESS_INSTANCE
----

image::switchyard/components/bpm/bpm_actions.jpg["BPM actions"]

== Starting a Process Instance
Operations configured with the *START_PROCESS* action type will start new process instances.

When you start your process (actually, any interaction with a service whose implementation is bpm), the processInstanceId will be put into the Switchyard Context at *Scope.MESSAGE*, and will be fed back to your client in a binding-specific way.  For soap, it will be in the form of a soap header in the soap response envelope:

[source,xml]
----
<soap:Header>
    <bpm:processInstanceId xmlns:bpm="urn:switchyard-component-bpm:bpm:1.0">1</bpm:processInstanceId>
</soap:Header>
----
In future process interactions, you will need to send back that same processInstanceId, so that the correlation is done properly.  For soap, that means including the same soap header that was returned in the response to be sent back with subsequent requests.

NOTE: If you are using persistence, the sessionId will also be available in the Context, and will need to be fed back as well.  It would look the same way in the soap header as the processInstanceId does.

== Correlation Keys
If you do not want to track the processInstanceId, however need to have multiple interactions with the same process instance, you can start the process with your own application-specific correlation key, and include that same correlation key for future interactions.  Here is an example of including in a a soap request:

[source,xml]
----
<soap:Header>
    <bpm:correlationKey xmlns:bpm="urn:switchyard-component-bpm:bpm:1.0">MY-APP-KEY-0123456789</bpm:correlationKey>
</soap:Header>
----

== Signaling a Process Instance
Operations configured with the *SIGNAL_EVENT* operation type will have the associated process instance signaled. 

NOTE: The processInstanceId will need to have been available in the Context so the correct process instance is correlated.

There are two other pieces of information when signaling an event:

* The *"event id"*.  In BPMN2 lexicon, this is known as the "signal id", but in jBPM can also be known as the "event type".  This is set as the eventId in the configuration.

NOTE: In BPMN2, a signal looks like this: <signal id="foo" value="bar"/>  In jBPM, it is the signal id that is respected, not the name.  This might require you to tweak a tooling-generated id to whatever you want it called.

* The *"event object"*.  This is the data representing the event itself, coming from the Message content object itself (your payload).

Operations configured with the *SIGNAL_EVENT_ALL* operation type will have all process instances signaled.

== Aborting a Process Instance
Operations configured with the *ABORT_PROCESS_INSTANCE* operation type will cause associated process instances to be aborted.

NOTE: The processInstanceId will need to have been available in the Context so the correct process instance is correlated.

== BPM Operations mappings
SwitchYard provides a flexible way to map data in and out service operation invocations via MVEL expressions.

image::switchyard/components/bpm/bpm_operations.png["Operations mappings"]

The above will create XML configuration like this:

[source,xml]
----
<operation name="process" type="START_PROCESS">
  <inputs>
    <input from="message.content.policy" to="Policy"/>
    <input from="message.content.driver" to="Driver"/>
  </inputs>
  <outputs>
    <output from="Policy" to="message.content"/>
  </outputs>
  <faults>
    <fault from="ProcessingFault" to="message.content"/>
  </faults>
</operation>
----

NOTE: All of the different mapping types support a from and to attribute. Those attributes get configured with MVEL expressions, which themselves support variables that can come from process or global variable names, implicit variable names, or variables that get resolved from properties.

== Globals
If your process executes business rules, you can use global mappings to access data in your rules which do not trigger rule execution themselves, but can be used in either the LHS or RHS of your rules for customization. 

== Inputs
For the BPM component, inputs are used to set process instance variables that can later be referenced by nodes within your process.

NOTE: For you to be able to use variables inside your process, you have to declare your variable names at the process level, as well as in the Parameter Mapping (and possibly Result Mapping) of any process node that wants access to those variables. This can be done easily in the BPMN2 Eclipse tooling by using the Properties view when clicking on either the whitespace around the process, or on any of your process nodes.

== Outputs
Outputs are used to extract process instance variables so that they can be set in the outgoing SwitchYard Message content.

== Faults
Fault mapping is similar to Output mapping, however the data represents an Exception or data that will be wrapped in an Exception.

== Implicit variables

* *context*: The current org.switchyard.Context.
* *message*: The current org.switchyard.Message.

Examples:
----
from="message.content" - This is the same as message.getContent().
from="context[‘foo’]" - This is the same as context.getProperty("foo", Scope.MESSAGE).getValue(), in a null-safe manner.
----

== Calling a BPM process
We are going to do a walk through of creating a BPM process and calling it from SwitchYard. Our process will call 3 other SwitchYard service as part of it orchestration logic.

image::switchyard/components/bpm/bpm_process_definition.png["Process Definition"]

Our process consist of one method, that receives an *Order* and answers with an *OrderAck*.

[source,java]
----
import org.switchyard.quickstarts.bpm.service.data.Order;
import org.switchyard.quickstarts.bpm.service.data.OrderAck;

public interface ProcessOrder {
    OrderAck submitOrder(Order order);
}
----

To invoke the BPM process, we select the properties for the BPM component in the Switchyard editor, and map the operations to BPM process events. For this particular example, we will map the *submitOrder* operation to trigger the start of the process with *START_PROCESS*, and we map the operation input and output data types to the process data types.

image::switchyard/components/bpm/process_properties_2.png["Process operation mapping"]

As can be seen, the operation input value is mapped with *message.content* to a process variable called *input_param*. For the operation return type, we get the process result, which will come in a process variable that we have called *output_result*. (By default, BPM will use an output variable called *Result*).

Our process definition is quite simple, it will invoke a SwitchYard service, and will evaluate the result of this invocation to decide which other service to call amongst two. The result of the invocation of this last service call will be used as a result of the whole process, this means, as a result of the operation being invoked.

image:switchyard/components/bpm/process.png["Process definition"]

To be able to interact with SwitchYard, we map the input and output parameters to "Process variables", as well as we declare some other variables to be used along the process execution.

image:switchyard/components/bpm/variables.png["Process Variables definition"]

When you want to invoke from a BPM process a *SwitchYard Service*, that means a SwitchYard "Reference", you just drop the *SwitchYardServiceTask* to the canvas and set the required properties. By default there will be the required properties for the invocation:

image:switchyard/components/bpm/switchyard_task_defaults.png["SwitchYard Service Task defaults"]

We then need to fill:

* *ServiceName*
* *OperationName*

And then map the SwitchYard Task invocation parameters, to the process variables. (Shown in red in the picture below)

image:switchyard/components/bpm/switchyard_task_params.png["SwitchYard Service Task params"]

In this example, we have copied the result of the call to the Inventory service into a process variable called *InventoryAvailable* that we use in the following gateway to select where to divert.

image:switchyard/components/bpm/divert.png["Exclusive gateway"]

Once the gateway selects the route to take, it is time to call last "SwitchYard Service", and again, setting up required fields and mappings to process variables. This time, the result of the execution of the SwitchYard Service will be mapped to the BPM process output.

image:switchyard/components/bpm/process_output.png["Process output mapping"]

NOTE: The name of the process defines the scope for the process variables. (ProcessOrder in this example)

== Rules Component
To create a new Rules service in SwitchYard, you'll need the following information

* *File Name*: the file name that will be used to create a new template rules definition.
* *Interface Type*: the contract for the service being provided.  Rules services support Java, WSDL, and ESB contract types.
* *Service Name*: the name of the service your process will provide.
* *Package Name*: package name used for the new Rules file.

image::switchyard/components/rules/new_rules.jpg[New Rules component]

== Rules Component

The ExampleService interface can be as simple as this (with no SwitchYard-specific imports):

[source,java]
----
package com.example.switchyard.docs;
public interface Example {
    public void process(MyData data);
}
----

The generated rule template will look like this:
[source,java]
----
package com.example.switchyard.docs
import org.switchyard.Message
global Message message
 
rule "RulesExample"
   when
      // insert conditional here
   then
      // insert consequence here
      System.out.println("service: ExampleService, payload: " + message.getContent());
end
----

== Rules Operations mappings
SwitchYard provides a flexible way to map data in and out service operation invocations via MVEL expressions.

image::switchyard/components/rules/rules_operations.png["Operations mappings"]

The above will create XML configuration like this:

[source,xml]
----
<operation name="process" type="EXECUTE">
  <globals>
    <global from="context['org.switchyard.messageId']" to="messageId"/>
  </globals>
  <inputs>
    <input from="message.content.policy"/>
    <input from="message.content.driver"/>
    <input from="context['org.example.foobar']"/>
  </inputs>
  <outputs>
    <output from="globals.Result" to="message.content"/>
  </outputs>
  <faults>
    <fault from="globals.Fault" to="message.content"/>
  </faults>
</operation>
----

== Generated rules service

[source,java]
----
package org.switchyard.example.docs
 
global java.lang.String messageId
global java.util.Map globals
 
rule "Approval"
    when
        policy : Policy(threshold >= 600)
    then
        policy.setFlag(true);
        globals.put("Result", policy);
end
 
rule "Denial"
    when
        policy : Policy(threshold < 600)
    then
        policy.setFlag(false);
        globals.put("Result", policy);
end
----

== Globals
If your process executes business rules, you can use global mappings to access data in your rules which do not trigger rule execution themselves, but can be used in either the LHS or RHS of your rules for customization. 

They also provide a nice way to define in/out "buckets" so you can get data out of rule execution.

[source,java]
----
   globals.put("resultingPolicy", policy);
----

IMPORTANT: The global variable called globals (java.util.Map) is always available for in/out purposes.  You don't have to configure it in your <globals> section for it to be available to your BPM/DRL.

== Globals - TIP
If you want to use your own application object as in in/out variable, you are free to do so.

You can even dynamically create your own Map using *MVEL* and name it what you want.

[source,xml]
----
<operation name="process" type="EXECUTE">
  <globals>
    <!-- the from is an MVEL construct which creates a new Map -->
    <global from="['':'']" to="holder"/>
  </globals>
  <outputs>
    <!-- this assumes you did a holder.put("out", someObject) at some point -->
    <output from="holder.out" to="message.content"/>
  </outputs>
</operation>
----

== Inputs
Inputs are the "facts" that are inserted into the Drools rules engine.

NOTE: If you do not specify your own Inputs, the default will be the incoming Message content. 

IMPORTANT: If you do specify your own Inputs, the incoming Message content will not be inserted as a fact, and you will have to include "message.content" yourself, if desired.

== Outputs
Using in/out variables (for example, the global Map called "globals"), we can extract data out of the rules execution and into the outgoing Message content.

IMPORTANT: If you do not specify your own Outputs, the default will be the result of the expression "globals.Result".

WARNING: If you do not specify your own Outputs, or in your DRL, you do not populate the "Result" of the globals Map, then your Rules component execution will return null. For IN_OUT Exchange patterns this is a problem.

== Faults
Fault mapping is similar to Output mapping, however the data represents an Exception or data that will be wrapped in an Exception.

== Stateless vs. Stateful Rules Execution

*Rules services are stateless by default*. Service method invocation will create a new Drools knowledge session, execute it given the passed-in domain data, and then be cleanly disposed.

*To use a stateful session*, use the FIRE_ALL_RULES action type instead of EXECUTE.

*To insert facts into a stateful knowledge session without firing the rules*, use the INSERT operation type.

== Channels
* Drools supports the notion of "Channels", which are basically "exit points" in your DRL.
* They can be used in both stateful and stateless sessions.

[source,java]
----
package com.example
rule "example rule"
    when
        $f : Foo ( bar > 10 )
    then
        channels["Bar"].send( $f.getBar() );
end
----

[source,xml]
----
<channels>
    <channel class="com.example.BarChannel" name="Bar"/>
</channels>
----

WARNING: Channels must implement org.kie.api.runtime.Channel.

== Consume another SwitchYard Service from a rules service
SwitchYard provides an out-of-the-box Channel which allows you to invoke (one-way) other SwitchYard services directly and easily from your DRL.

[source,xml]
----
<channel name="HelloWorld" reference="HelloWorld" operation="greet"/>
----

Parameters to the SwitchYard channel
* *class*: The channel implementation class. (Default is SwitchYardServiceChannel.)
* *name*: The channel name. (default = simple name of the implementation class)
* *reference*: The service reference qualified name.
* *operation* The service reference operation name.

== Complex Event Processing - Configure
How to configure via XML? (it can be done via JBDS tooling)

[source,xml]
----
<implementation.rules ...>
    <operations>
        <operation eventId="FooStream" name="processFooMessage" type="FIRE_UNTIL_HALT"/>
        <operation eventId="BarStream" name="processBarMessage" type="FIRE_UNTIL_HALT"/>
    </operations>
    ...
    <properties>
        <property name="drools.clockType" value="realtime"/>
        <property name="drools.eventProcessingMode" value="stream"/>
        <property name="drools.maxThreads" value="1"/>
        <property name="drools.multithreadEvaluation" value="false"/>
    </properties>
</implementation.rules>
----

NOTE: The type of "FIRE_UNTIL_HALT" is required for CEP scenarios.

== Complex Event Processing - Insert facts
*How do facts (data) get inputted for CEP?*

Operations of type FIRE_UNTIL_HALT can specify <inputs> just like any other operation. If all of your inputs have "from" attributes but not "to" attributes, then:

* If the "eventId" attribute on the operation element is set, then the eventId is your entry point that the data gets inserted into. (Unicast)
* If the "eventId" attribute on the operation element is not set, then everything gets inserted into the stateful session, not into an entry point. ((Multicast)

== KnowledgeServices Listeners
Listeners are used to monitor specific types of events that occur during Knowledge execution.

[source,xml]
----
<listeners>
    <listener class="org.drools.core.event.DebugProcessEventListener"/>
    <listener class="org.kie.api.event.rule.DebugWorkingMemoryEventListener"/>
    <listener class="com.example.MyListener"/>
</listeners>
----

== KnowledgeServices Loggers
Loggers are special types of Listeners, and are used to output the events that occur during Knowledge execution. Events can be logged to the CONSOLE or to a FILE.

[source,xml]
----
<loggers>
    <logger interval="2000" log="myLog" type="THREADED_FILE"/>
    <logger type="CONSOLE/>
</loggers>
----

== KnowledgeServices MANIFEST
MANIFEST is where you specify where the "intelligence" of the component comes from. 

* For the *BPM* component, this will be, at the minimum, the location of the BPMN 2 process definition file.
* For the *Rules* component, this will most likely be the location of DRL, DSL, DSLR or XLS files. 

There are two ways to to configure the Manifest:

* With a KIE Container. This relies upon the existence of a META-INF/kmodule.xml configuration file.
* With a manually defined list of Resources.

WARNING: These two options are mutually exclusive.

.META-INF/kmodule.xml
[source,xml]
----
<kmodule xmlns="http://jboss.org/kie/6.0.0/kmodule">
    <kbase name="com.example">
        <ksession name="my-session" type="stateless"/>
    </kbase>
</kmodule>
----

.META-INF/switchyard.xml
[source,xml]
----
....
<bpm:implementation.bpm persistent="false" processId="ProcessOrder">
   <bpm:manifest>
      <!-- // This element is needed when the ksession is defined in the kmodule.xml
      <bpm:container sessionName="my-session"/> 
      -->
      <bpm:resources>
         <bpm:resource location="ProcessOrder.bpmn" type="BPMN2"/>
         <bpm:resource location="com/example/MyRules.drl" type="DRL"/>
      </bpm:resources>
   </bpm:manifest>
   ...
</bpm:implementation>
...
----

== KnowledgeServices Configuration Properties
Properties are the way to provide "hints" to the underlying KIE/Drools/jBPM runtime on how certain options are configured.

WARNING: Properties are an advanced topic, so setting them should be done with care.

NOTE: All possible property names and values will not be listed here. To view them, in your IDE open up a Type Heirarchy with a root of *org.kie.api.conf.Option*.

[source,xml]
----
<properties>
    <property name="drools.clockType" value="pseudo"/>
    <property name="drools.eventProcessingMode" value="stream"/>
</properties>
----
== Core concepts

SwitchYard uses Camel internally to communicate between its parts (bindings and components) and follows Camel concepts in terms of Messages, Exchange, ...

image::switchyard/core_switchyard.png[SwitchYard Core concepts]

== Core concepts - org.switchyard.Message

A Message represents an individual input or output of a service, the content of which is interpreted by service implementation logic.

A Message does not carry context specific to a service invocation, which means that it can be copied and reused across service invocations. There are two distinct parts to a message:

* *Content*: the main body, or payload, of the message. There is only one body per message instance. The message body is mutable, so message processing logic can access the content, change it (transform, enrich, etc.), and then set it back on the message.
* *Attachments*: provide the ability to associate content with a message separate from  the main body, allowing it to be parsed independently. One example  would be a binary image that is referenced by the main body of the message.  The attachment may be too large to be processed in certain services or the service implementation may not be able to  parse/interpret it.

== Core concepts - org.switchyard.Exchange

An Exchange provides a conduit for the messages that flow into and out of a service  as part of a service invocation.

An Exchange represents an instance of a service invocation with a specific message exchange pattern (e.g. InOnly, InOut).  

Unlike messages, an exchange cannot be copied and reused across service invocations. State associated with an invocation (i.e. context) is maintained at the exchange level.

* *org.switchyard.ExchangePhase*: Represents the phase of an exchange. (INPUT or OUTPUT)

* *org.switchyard.ExchangeState*: Represents the state of an Exchange (OK, FAULT)

* *org.switchyard.ExchangePattern*: The list of supported exchange patterns within SwitchYard. (IN_ONLY, IN_OUT)

* *org.switchyard.metadata.ExchangeContract*: Two-way Exchange contract, detailing the requirements of both the consumer and provider ServiceOperation being invoked.

== Core concepts - org.switchyard.Context

Holds contextual information around the exchange of messages between a service consumer and provider.

== Core concepts - org.switchyard.Service

A service registered with the SwitchYard runtime.

== Core concepts - org.switchyard.ServiceReference

A service registered with the SwitchYard runtime.

== Core concepts - org.switchyard.ServiceDomain

A ServiceDomain represents a collection of services with a shared set of resources, configuration, and policy definitions.  The ServiceDomain interface is used by software components to provide and/or consume services.  These software components include protocol gateways, service containers, translation engines, adapters, orchestration and routing engines.

== Core concepts - org.switchyard.metadata.ServiceOperation
epresentation of an operation on a ServiceInterface. Each operation has:

* an exchange pattern (IN_OUT, IN_ONLY)
* a name
* an input message referenced type
* an (optional) output message type
* an (optional) fault message type

The mapping of operation and message names is defined by the concrete implementation of ServiceInterface.  For example, the expected mapping of a Java interface would be Java method name to ServiceInterface operation name.

== Core concepts - org.switchyard.metadata.ServiceInterface
The canonical representation of a service interface in SwitchYard.  

Every service in SwitchYard is registered with exactly one ServiceInterface, providing information on the type, operations, and input/output messages for the service. 

The SwitchYard runtime provides concrete implementations of ServiceInterface for Java and WSDL interface types. 

There is also a default type of *ServiceInterface.DEFAULT_TYPE* which is used to represent services which do not publish a formal contract.

== Core concepts - org.switchyard.ServiceMetadata
Contains runtime details on services and service references registered in SwitchYard.

Instances of ServiceMetadata can be created and updated using the ServiceMetadataBuilder class

== Core concepts - org.switchyard.ExchangeHandler
The role of a Handler is to handle messages and fault events during the course of a service invocation.

When consuming a service, a handler can be registered during Exchange creation to handle consumer events (e.g. fault or reply message).

When providing a service, a handler is specified while registering the service to process invocations of that service.

== Core concepts- How an Exchange works

TODO: Describe how an Exchange goes from one ServiceHandler/Exchange to another ServiceHandler/ExchangeHandler, how the message is created. How to create and set new messages back in the Exchange, What is the pipeline that drives the Exchange lifecycle,...

== Core concepts - 

== Core concepts - ServiceHandlers

Every SwitchYard application has a composite service with one or multiple bindings. 

Every binding acts as an endpoint. Incoming endpoint if it is a binding on a service or outgoing endpoint if it is a binding on a reference. 

This endpoints are created, registered and started when the aplication gets deployed, and are stoped, unregistered and destroyed when the application is undeployed.

Every endpoint implements *org.switchyard.deploy.ServiceHandler*

There are inbound handlers and outbound handlers, depending if they act as server endpoints or client endpoints.

Inbound handlers:

* org.switchyard.component.camel.common.handler.InboundHandler: An handler that acts as a gateway/entrypoint for Camel Components.
* org.switchyard.component.http.InboundHandler: Hanldes HTTP requests to invoke a SwitchYard service.
* org.switchyard.component.resteasy.InboundHandler: Handles RESTEasy requests to invoke a SwitchYard service.
* org.switchyard.component.soap.InboundHandler: Handles SOAP requests to invoke a SwitchYard service.
* org.switchyard.component.sca.SCAEndpoint: For publishing services as SCA

Outbound handlers:

* org.switchyard.component.camel.common.handler.OutboundHandler: A handler that is capable of calling Apache Camel components.
* org.switchyard.component.http.OutboundHandler: Handles invoking external HTTP services.
* org.switchyard.component.resteasy.OutboundHandler: Handles invoking external RESTEasy services.
* org.switchyard.component.soap.OutboundHandler: Handles invoking external Webservice endpoints.
* org.switchyard.component.sca.SCAInvoker: Handles outbound communication to an SCA service endpoint

image::switchyard/service_handlers.jpg[Service Handlers]

== How does an InboundHandler Works

When it is created, an instance of the BindingModel (configuration) is passed, as well as an instance of the ServiceDomain, is passed to the InboundHandler.

When it starts creates the ServiceReference representing the endpoint, the endpoint for the corresponding binding and the message composer.

Provides one method, *invoke*, where all the logic for an invocation to the endpoint happens.

When it stops, the endpoint is stopped.

== InboundHandler.invoke()

* creates an Exchange
* add identy to the Exchange to identify the origin of the invocation
* compose the message (*MessageComposer.compose()*) from the passed binding Message (*BindingData*)
* send the Message to the Exchange (*Exchange.send()*)
* If it is IN_OUT:
** it will wait for a response (Default timeout of 5 minutes)
** it will decompose the response (*MessageComposer.decompose()*)
* it returns the decomposed message as *BindingData*

== How does a message translation works
Here we will find a description of what is happening at the message composition time in a call to a SwitchYard application through an external binding and having one call to an external reference through a binding.

image::switchyard/core/MessageComposition_Flow.jpg[Message composition flow]

. *Request message from binding to service (Request from client)*. The request message is converted from the binding message type to the internal SwitchYard *Message*, and all the binding headers (HTTP, SOAP, ...) will be mapped into the corresponding properties in the SwitchYard *Context* associated to the Message, and it is set to the Exchange.
. *Service component implementations execution*. The request pipelines of a component will be executed, until a there is a call to an external service.
. *Request message from reference to binding (External service call)*. A call to the external service is about to happen, and message needs to be converted from SwitchYard Message to the reference binding data, the MessageComposer will decompose the message back to the binding format and properties will be extracted from the SwitchYard *Context* and set into the binding message. 
. *Response message from binding to reference (Response from remote service)*. Once the external service has been executed, the response from this external service will be mapped back into SwitchYard by the MessageComposer.mapFrom(). The ContextMapper will copy the appropiate message/transport headers back into the Message *Context* 
. *Service execution*. The rest of the components` pipeline will be executed.
. *Response message from service to binding (Response to client caller)*. When our application has ended it's execution and it is returning the result to the caller, the MessageComposer will decompose the SwitchYard message back to the binding message and the ContextMapper will map the properties in the Context back to the binding message.

NOTE: Additional behaviour relative to the correspoding transaltions will exist in the predefined MessageComposers and ContextMappers (SOAP, REST, HTTP,...) 

== How does an OutboundHandler Works

TODO: Define this.

TODO: How and when message composition happens
TODO: How and when validation, transformation, ... happens 


== Binding/Gateways
 ** Http based
 ***  SOAP
 ***  RESTEasy
 ***  HTTP
 ** Camel based
 *** JPA
 *** JCA
 *** JMS
 *** SQL
 *** File
 *** FTP FTPS SFTP
 *** TCP UDP
 *** Quartz
 *** Timer
 *** SEDA
 ** SCA
 ** Camel URI*
 ** MessageComposers/MessageContext
 ** Operation selection
 ** Throttling

== SOAP Binding
The SOAP component in SwitchYard provides SOAP-based web service binding support for services and references. 

In FSW it is based in *JBossWS-CXF*.

== SOAP Service Binding - Details
Basic configureation

image::switchyard/bindings/soap/binding_service_soap_1.png[Soap Service binding]

* *wsdl*: location of the WSDL used to describe the web service endpoint.
* *wsdlPort*: port name in the WSDL to use.  If unspecified, the first port definition in the WSDL is used for the service endpoint
* *socketAddr*: the IP Socket Address to be used. The value can be in the form hostName/ipAddress:portNumber or hostName/ipAddress or :portNumber.
* *contextPath*: additional context path for the SOAP endpoint. (Default is none)

* *unwrapped Payload*: Checking this option it will unwrap the message's payload (explained later).
* *SOAP Headers Type*: How it will extract the SOAP headers into SwitchYard (explained later)
* *Endpoint Configuration*: cxf.xml configuration file for external endpoint configuration (Does not work)
* *MTOM*: Enable Message Transmission Optimization Mechanism for attachments

== SOAP Service Binding - Interceptors
Configure CXF interceptors for Inbound and Outbound pipelines

image::switchyard/bindings/soap/binding_service_soap_2.png[Soap Service binding]

== SOAP Service Binding - Message Composer
Configure message composition for SOAP messages. (Exlained later)

image::switchyard/bindings/soap/binding_service_soap_3.png[Soap Service binding]

== SOAP Service Binding Example
[source,xml]
----
<sca:composite name="orders" targetNamespace="urn:switchyard-quickstart-demo:orders:0.1.0">
   <sca:service name="OrderService" promote="OrderService">
      <soap:binding.soap name="soap1">
         <soap:contextMapper includes="custom.*" soapHeadersType="XML"/>
         <soap:messageComposer unwrapped="true"/>
         <soap:wsdl>META-INF/orderService.wsdl</soap:wsdl>
         <soap:wsdlPort>OrderPort</soap:wsdlPort>
         <soap:socketAddr>:9091</soap:socketAddr>
         <soap:contextPath>order-test</soap:contextPath>
         <soap:endpointConfig configFile="SecureEndpointConfig.xml" 
                              configName="SecureOrder"/>
         <soap:mtom threshold="1500" xopExpand="true"/>
         <soap:inInterceptors>
            <soap:interceptor class="org.apache.cxf.interceptor.LoggingInInterceptor"/>
         </soap:inInterceptors>
         <soap:outInterceptors>
            <soap:interceptor class="org.apache.cxf.interceptor.LoggingOutInterceptor"/>
         </soap:outInterceptors>
      </soap:binding.soap>
   </sca:service>
</sca:composite>
----

== SOAP Service Binding - Unwrapped payload
It will remove the wrapper part of the message, which usually translates to the operation for you.

[source,xml]
----
<soap:Body>  
   <orders:submitOrder xmlns:orders="urn:switchyard-quickstart:bean-service:1.0">  
      <order>  
         <orderId>PO-19838-XYZ</orderId>  
         <itemId>BUTTER</itemId>  
         <quantity>200</quantity>  
      </order>  
   </orders:submitOrder>  
</soap:Body>  
----

The message you will be passed will be:
[source,xml]
----
<order xmlns:orders="urn:switchyard-quickstart:bean-service:1.0">  
   <orderId>PO-19838-XYZ</orderId>  
   <itemId>BUTTER</itemId>  
   <quantity>200</quantity>  
</order>
----

NOTE: if (unwrapped){ ...// peel off the operation wrapper, if present ...}

IMPORTANT: It will unwrap the request and wrap back the response (if not already wrapped).
  
See: 

* org.switchyard.component.soap.composer.SOAPMessageComposer.compose(...)
* org.switchyard.component.soap.composer.SOAPMessageComposer.decompose(...)

== SOAP Headers type

Header sent:

[source,xml]
----
<typ:amount xmlns:typ="http://ws.camelcookbook.org/payment-service/types">1000</typ:amount>
----

* *CONFIG*: *org.switchyard.config.Configuration* object based on the SOAP header
* *DOM*: XML representation of the element, in DOM format. 
* *Value*: Value of the element (1000)
* *XML*: String representation of the SOAP header XML element.

See: *org.switchyard.component.soap.composer.SOAPContextMapper.mapFrom(...)*

== SOAP Service Binding CAVEATS

* The url where the service is published can only be known at deploy time from the logs.
* The url is composed in the form of http://<host>:<port>/<artifactName>/<context>/<xxxx>
* In AS7 by default the JBossWS-CXF stack is enabled and hence the socketAddr parameter will be ignored. This parameter can be used for standalone usage (Unit tests).

== SOAP Reference Service Binding
Binding a reference with SOAP can be used to make SOAP-based web services available to SwitchYard services.

image::switchyard/bindings/soap/binding_reference_soap_1.png[Soap reference binding]

== SOAP Reference Binding

image::switchyard/bindings/soap/binding_reference_soap_2.png[Soap reference binding]

== SOAP Reference Binding

image::switchyard/bindings/soap/binding_reference_soap_3.png[Soap reference binding]

== SOAP Reference Binding

image::switchyard/bindings/soap/binding_reference_soap_4.png[Soap reference binding]

== SOAP Binding Capabilities

* *WS-Security*
** *UsernameToken Support*
** *Signature and Encryption Support*
* *Attachments* (y default any attachment sent with a SOAP Envelope is passed around in a SwitchYard Message as an attachment. The default SOAPMessageComposer handles this.)
** *SOAP with Attachments (SwA)*
** *SOAP with MTOM/XOP*:
* *WS-Addressing*

See: https://docs.jboss.org/author/display/SWITCHYARD/SOAP

== Switchyard - RESTEasy Binding

 TODO: Create this

== Switchyard - HTTP Binding

 TODO: Create this

== Switchyard - JPA Binding

 TODO: Create this

== Switchyard - JCA Binding

 TODO: Create this

== Switchyard - JMS Binding

 TODO: Create this

- Where does #ConnectionFactory come from???
https://community.jboss.org/thread/243227
- use custom jndiPropertiesFile
- Use a .ra
- Configuration for tests with hornetq-jms.xml, hornetq-ra.xml, ...

== Switchyard - SQL Binding

 TODO: Create this

== Switchyard - File Binding

 TODO: Create this

== Switchyard - FTP FTPS SFTP Binding

 TODO: Create this

== Switchyard - TCP UDP Binding

 TODO: Create this

== Switchyard - Quartz Binding

 TODO: Create this

== Switchyard - Timer Binding

 TODO: Create this

== Switchyard - SEDA Binding

 TODO: Create this

== Switchyard - SCA Binding

 TODO: Create this

== Switchyard - Camel URI Binding

 TODO: Create this

== Switchyard - Message Composers
A MessageComposer can compose or decompose a native binding message to/from SwitchYard's canonical message.  A MessageComposer does this in three steps:

1. Construct a new target message instance.
2. Copy the content ("body") of the message.
3. Delegate the header/property mapping to a ContextMapper.

 We currently provide a SOAPMessageComposer, a CamelMessageComposer, and a HornetQMessageComposer.  These default implementations are used by their associated bindings, but can be overridden by the user.

 TODO: Check if more message composers exist (RESTeasyMessageCOmposer)

== Switchyard - Custom Message Composers

 TODO: Create this

== Switchyard - Context Mappers
A ContextMapper moves native binding message headers and/or properties to/from SwitchYard's canonical context.  

   Many ContextMapper implementations are provided OOTB).  These default implementations are used by their associated bindings, but can be overridden by the user.

* *SOAPContextMapper*: when processing an incoming SOAPMessage, takes the mime (in most cases, HTTP) headers from a soap envelope and maps them into the SwitchYard Context as Scope.MESSAGE properties with the SOAPComposition.SOAP_MESSAGE_MIME_HEADER label, and takes the soap header elements from the soap envelope and maps them into the SwitchYard Context as Scope.EXCHANGE properties with the SOAPComposition.SOAP_MESSAGE_HEADER label. When processing an outgoing SOAPMessage, it takes the SwitchYard Scope.OUT Context properties and maps them into mime (in most cases, HTTP) headers, and takes the SwitchYard Scope.EXCHANGE Context properties and maps them into the soap envelope as soap header elements.

* *CamelContextMapper*
* *HornetQContextMapper*
* *HTTPContextMapper*
* *RESTEasyContextMapper*
* *CCIIndexedRecordContextMapper*, *CCIMappedRecordContextMapper*, *JMSContextMapper* (JCA binding)

 TODO: Create this

Here we will find a description of what is happening at the message composition time in a call to a SwitchYard application through an HTTP binding and having one call to an external reference through an HTTP binding.

image::switchyard/core/MessageComposition_Flow.jpg[Message composition flow]

==== (1) Request message from binding to service (Request from client)
The request message is converted from the binding message type to the internal service type. For this to happen, a call to *HttpMessageComposer.compose()*.

In this method two things will happen:

* It will create a *Message* for the *Exchange*.

* A call to *HttpContextMapper.mapFrom(HttpRequestBindingData, context)* will be done. This method will:

** It will copy *requestInfo* from the *HTTPRequestBindingData* into the message *Context* with key *HttpComposition.HTTP_REQUEST_INFO* and assigning the following labels, *ComponentLabel.HTTP* and *EndpointLabel.HTTP*

NOTE: HttpRequestInfo has all the required information from the request, and is the source of information that can be used in the SwitchYard's component implementations to access information relative to the request, such as requestURI, requestPath, method, contextPath,... link:https://github.com/jboss-switchyard/components/blob/master/http/src/main/java/org/switchyard/component/http/composer/HttpRequestInfo.java#L35-L56[See the implementation of this class to find all the available information].

** It will copy all headers from the HTTP request that match the defined includes and exludes regex pattern for the composer at design time.

NOTE: Headers are not automatically copied, you have to add to messageComposer which headers you want to include (.*: all)

image::switchyard/core/MessageComposer_Configuration.png[Message Composer Configuration]

WARNING: When checking for headers, or defining headers in Binding's RegEx Inclusion and Exclusion, all headers are *lowercased*. If you send a header *Authorization*, you should check for *authorization* instead.

* It will copy the content from the *HttpBindingData* to the *Message* that will flow through SwitchYard converting it to the appropiate type.

* It will return the *Message*.

==== (2) Service component implementations execution
The request pipelines of a component will be executed, until a there is a call to an external HTTP service.

==== (3) Request message from reference to binding (External service call)
A call to the external service is about to happen, and message needs to be converted from SwitchYard message to the reference binding data.

* A call to *HttpMessageComposer.decompose(Exchange, HttpRequestBindingData)* will be done. This method will:
** Copies the content from the *Exchange* to the content *HttpRequestBindingData*
** Calls *HttpContextMapper.mapTo(Request)* to copy headers from the Message`s *Context* to the HttpRequestBindingData's http headers. These properties will be copied only if they match the registered regexp expressions in the MessageComposer's design time configuration or if the properties are marked with the EndpointLabel.HTTP label in the Context.


==== (4) Response message from binding to reference (Response from remote service)
Once the external service has being executed, we have to deal with the response from this external service, and map it back into SwitchYard. To to this, a call to *HttpMessageComposer.compose(HttpResponseBindingData, Exchange) will be done. This method will:

* Create a Message

* Call *HttpContextMapper.mapFrom(HttpResponseBindingData, Message)* that will:
** Copies the statusCode of the invocation into a Context property called *HttpContextMapper.HTTP_RESPONSE_STATUS* with labels http (ComponentLabel.HTTP and EnpointLabel.HTTP)
** It will copy all headers from the HTTP response that match the defined includes and exludes regex pattern for the composer at design time.

NOTE: Headers are not automatically copied, you have to add to messageComposer which headers you want to include (.*: all)

* It will copy the content from the *HttpBindingData* to the *Message* that will flow through SwitchYard converting it to the appropiate type.

* It will return the *Message*.

==== (5) Service execution
The rest of the components` pipeline will be executed.

==== (6) Response message from service to binding (Response to client caller)
When our application has ended it's execution and it is returning the result to the caller, it will call again *HttpMessageComposer.decompose(Exchange, HttpResponseBindingData)* to convert the SwitchYard message to the binding message or content.
It will:
* Get statusCode from Context property *HttpContextMapper.HTTP_RESPONSE_STATUS* that has been established as part of the SwitchYard service execution.

NOTE: This property could be the one that was set from the invocation to the external Composite's Reference. (In step 4)

- If there is no statusCode set as a property, or this statusCode property does not have the *EndpointLabel.HTTP*  label, it will calculate one depending on the content and on the *Exchange.getState*. If the state of the Exchange is *ExchangeState.FAULT* it will return an HTTP Error code of *500*. (link:https://github.com/jboss-switchyard/components/blob/master/http/src/main/java/org/switchyard/component/http/composer/HttpMessageComposer.java#L73-L88[See the code for the logic determining the statusCode])
* Copy the content from the SwitchYard's *Message* to the *HttpResponseBindingData*
* Call HttpContextMapper.mapTo(HttpResponseBindingData) that will:
** Copy headers from the Message`s *Context* to the HttpRequestBindingData's http headers. These properties will be copied only if they match the registered regexp expressions in the MessageComposer's design time configuration or if the properties are marked with the EndpointLabel.HTTP label in the Context.
** If the property is *HttpContextMapper.HTTP_RESPONSE_STATUS* it will set the status on the HttpResponseBindingData


== HOWTOS

=== How to pass a header from an incoming request to use it in the SwitchYard application
You need to add the header in the Message Composer design time configuration screen for the Composite Service Http Binding.

image::switchyard/core/pass_header.png[Authorization header]

NOTE: Remember that headers are *lowercased*.

If you want to progress this header to a Composite Reference, you need to add it again to the Composite Reference Http Binding's Message Composer design time configuration screen

=== How to send a header to an outgoing request
You need to add the header in the context of the invocation with EndpointLabel.HTTP. To be able to modify aspects of the call to the reference, this need to be done as a ReferenceInvoker rather than as a regular Reference.

[source,java]
----
   @Inject
   @Reference("RealHttpService")
   private ReferenceInvoker referenceInvoker;

	public String myBeanMethod(String params){
	String replyContent = "";
		ReferenceInvocation invocation = null;

		try{
			invocation = referenceInvoker.newInvocation();
	   	Context context = invocation.getMessage().getContext();

	   	// Set the header we want
	   	context.setProperty("Authorization", "xxxx").addLabels(EndpointLabel.HTTP.label());

	   	// Call the service
	   	replyContent = invocation.invoke(params).getMessage().getContent(String.class);
	   }catch(Exception e){
			// Manage exception
	   }
   	return replyContent;
   }
----

=== How to change configuration for calling service (method, queryString, queryArgs). How to invoke dynamically

WARNING: This is not possible with HTTP Binding reference. You have to use Camel binding reference.

image::switchyard/core/camel_reference_binding.png[Camel Reference binding]

To be able to modify aspects of the call to the reference, this need to be done as a ReferenceInvoker rather than as a regular Reference.

[source,java]
----
   @Inject
   @Reference("RealHttpService")
   private ReferenceInvoker referenceInvoker;

	public String myBeanMethod(String params){
	String replyContent = "";
		ReferenceInvocation invocation = null;

		// We get information from incoming request
      HttpRequestInfo requestInfo = msgContext.getPropertyValue(HttpComposition.HTTP_REQUEST_INFO);

		try{
			invocation = referenceInvoker.newInvocation();
	   	Context context = invocation.getMessage().getContext();

	   	// We copy (progress)  method, path and query string
	   	context.setProperty(org.apache.camel.Exchange.HTTP_METHOD, requestInfo.getMethod());
      	context.setProperty(org.apache.camel.Exchange.HTTP_URI, "http://localhost:8080" +  requestInfo.getPathInfo());
      	context.setProperty(org.apache.camel.Exchange.HTTP_QUERY, requestInfo.getQueryString());

	   	// Call the service
	   	replyContent = invocation.invoke(params).getMessage().getContent(String.class);
	   }catch(Exception e){
			// Manage exception
	   }
   	return replyContent;
   }
----

=== How to check the status code of an invocation to an external service
You need to check for the following context Property *HttpContextMapper.HTTP_RESPONSE_STATUS*

----
   @Inject
   @Reference("RealHttpService")
   private ReferenceInvoker referenceInvoker;

	public String myBeanMethod(String params){
	String replyContent = "";
		ReferenceInvocation invocation = null;

		try{
			invocation = referenceInvoker.newInvocation();
			....
	   	// Call the service
	   	replyContent = invocation.invoke(params).getMessage().getContent(String.class);
	   }catch(Exception e){
			int statusCode = invocation.getContext().getPropertyValue(HttpContextMapper.HTTP_RESPONSE_STATUS)
			// Manage exception
			...
	   }
   	return replyContent;
   }
----

=== How to set the status code of an invocation to a SwitchYard application
You need to set the following context Property *HttpContextMapper.HTTP_RESPONSE_STATUS* with label *EndpointLabel.HTTP*. In order to do this in a component, you need to create a new Message and send it to the Exchange.

In a BeanComponent:

[source,java]
----
   private void replyWithHTTPStatusCode(Exchange currentExchange, int statusCode) {
      Message reply = currentExchange.createMessage();
      reply.getContext().setProperty(HttpContextMapper.HTTP_RESPONSE_STATUS, statusCode).addLabels(EndpointLabel.HTTP.label());
      currentExchange.send(reply);
   }
----

In a CamelComponent:

In a Route:

[source,java]
----
	.to("EXTERNAL_SERVICE")
	.setHeader(HttpContextMapper.HTTP_RESPONSE_STATUS, constant(200))
----

In a Processor:

[source,java]
----
    exchange.getIn().setHeader(HttpContextMapper.HTTP_RESPONSE_STATUS, statusCode);
----

=== How to copy all HTTP incoming headers and progress them
Right now there is no way to copy all headers from Http service binding to an Http Reference Binding but to specify all the headers you want to copy in the regex includes field for both MessageComposers.
Another option is to create your own MessageComposer, that extends the basic HttpMessageComposer and copy all the headers in the context in the Service Binding, and then set them back in the Reference Binding.

== MessageComposer

[source,java]
----
public interface MessageComposer<D extends BindingData> {
    public ContextMapper<D> getContextMapper();
    public MessageComposer<D> setContextMapper(ContextMapper<D> contextMapper);

    public Message compose(D source, Exchange exchange) throws Exception;
    public D decompose(Exchange exchange, D target) throws Exception;
}
----

== ContextMapper

[source,java]
----
public interface ContextMapper<D extends BindingData> {
    public ContextMapperModel getModel();
    public void setModel(ContextMapperModel model);

    public void mapFrom(D source, Context context) throws Exception;
    public void mapTo(Context context, D target) throws Exception;
}
----


== SwitchYard - Scopes

* Headers are scoped as MESSAGE. You will see some headers specifically useful for http requests, and other headers specifically useful for http responses.  In both cases, they are most likely tied to the binding's notion of an incoming message or an outgoing message.

* Properties are scoped as EXCHANGE, as this is most likely application or domain data, and possibly useful in the entire processing of the Exchange.

== Switchyard - Custom Context Mappers

 TODO: Create this


== Switchyard - Operation selection

 TODO: Create this

== Switchyard - Throttling

 TODO: Create this

== SwitchYard - Transformations (Java, JAXB, JSON, Smooks, XSLT, ...)

When is a transformation required:

 When origin type and destination type of a "wire connection" is not of the same type, and implicit type conversion (provided by Camel type converters) can not convert between both types.

 Declarative transformation only kicks in when the runtime detects that the message type is different between the consumer and provider contracts.

The tooling reflects this as well, which is why if there are no interactions where contract types differ, then you cannot create a transformer. There are three scenarios in SY where the contract types can differ and require a transformation:
 
1. A composite service interface is different from the component service interface it promotes.
2. A component reference interface is different from the component service interface it is wired to.
3. A composite reference interface is different from the component reference interface it promotes.

* Different implementations for transformations:
** Java
** JAXB
** JSON
** Smooks
** XSLT
** Transformations in a Camel component
** Other (coming next: Dozer,...)

TODO: http://www.mastertheboss.com/jboss-soa/switchyard-tutorial/page-2

== SwitchYard - Transformations - Content Type Names

Since transformations occur between named types (i.e. from type A, to type B), it's important to understand how the type names are derived. The type of the message is determined based on the service contract, which can be WSDL or Java.

For WSDL interfaces, the message name is determined based on the fully-qualified element name of a WSDL message.  Take the following WSDL definition:

[source,xml]
----
<definitions xmlns:tns="urn:switchyard-quickstart:bean-service:1.0">  
  <message name="submitOrder">
    <part name="parameters" element="tns:submitOrder"/>
  </message>
  <portType name="OrderService">
    <operation name="submitOrder">
      <input message="tns:submitOrder"/>
    </operation>
  </portType>
</definitions>
----

This would yield the following message type name based on the message element name defined in the WSDL:

[source,java]
----
{urn:switchyard-quickstart:bean-service:1.0}submitOrder
----

When Java interfaces are used for the service contract, the message name consists of the full package name + the class name, prefixed with "java:".

[source,java]
----
package org.switchyard.example;
public interface OrderService {
    void submitOrder(Order order);
}
----

The message type name for the submitOrder method in this Java interface would be *"java:org.switchyard.example.Order"*.  

Occasionally, it can be useful to override the default operation name generated for a Java interface. The *@OperationTypes* annotation provides this capability by allowing the user to specify the input, output, and/or fault type names used for a Java service interface. 

For example, if we wanted to accept XML input content without any need for transformation to a Java object model, the OrderService interface could be changed to look like this:

[source,java]
----
package org.switchyard.example;
public interface OrderService {
    @OperationTypes(in = "{urn:switchyard-quickstart:bean-service:1.0}submitOrder")
    void submitOrder(String orderXML);
}
----

Aside from short-circuiting the requirement for transformation, this annotation can be useful if you want to maintain tight control over the names used for message content.

== SwitchYard - Transformations

Required transformations are automatically detected by IDE, but, if missing, can be created/deleted/recreated manually:

image::switchyard/transformers/no_missing_transformer.png[All required validators have been added]

If you remove all/any of the transformers, you will be able to create missing required transformers:

image::switchyard/transformers/required_transformers.png[Create required transformer]

A new dialog will let you create a new transformer:

image::switchyard/transformers/new_transformer_all.png[New Transformer]

== SwitchYard - Transformations - Java
Java transformer let you do any kind of transformation using Java for this purpose. There are two methods available for creating a Java-based transformer in SwitchYard:

1. Implement the *org.switchyard.transform.Transfomer* interface and add a *<transform.java>* definition to your switchyard.xml.
2. Annotate one or more methods on your Java class with *@Transformer*.

 When using the @Transformer annotation, the SwitchYard maven plugin will automatically generate the <transform.java> definition(s) for you and add them to the switchyard.xml packaged in your application.

Implementing Java transformations is just a matter of creating a new (Java) Transformer on the SwitchYard application:

image::switchyard/transformers/new_transformer.png[New validator]

And selecting Java as the type of transformer you want implementing class or bean.

image::switchyard/transformers/new_java_transformer.png[Create a Java transformer]

It will create the appropiate transformer class/bean with the default annotated methods:

image::switchyard/transformers/java_transformer.png[Java Transformer class]

 The optional from and to elements of the @Transformer annotation can be used to specify the qualified type name used during transformer registration.  If not supplied, the full class name of the method parameter will be used as the from type and the full class name of the return type will be used as the to type.

And the corresponding configuration in the switchyard.xml file:

image::switchyard/transformers/transformer_switchyard_xml.png[Transformers defined in switchyard.xml file]

 The CDI bean name specified by @Named annotation is used to resolve transformer class. If you don't specify, then class name of the transformer is used instead.

== SwitchYard - Transformations - JAXB

The JAXB transformer allows you to perform Java to XML (and XML to Java) transformations using JAXB (XML marshalling and unmarshalling).

 JAXB Java models can be generated from an XML Schema using XJC, or from a WSDL using tools like wsconsume, or from within JBDS IDE with "JAXB`s JAXB classes from Schema" or "SwitchYard`s Java Files from WSDL".

JAXB Transformer requires a *to* and *from* with one Java type and one QNamed XML type, depending on whether you're performing a Java to XML or XML to Java transformation.

[source,java]
----
@XmlElementDecl(namespace = "http://com.acme/orders", name = "create")
public JAXBElement<CreateOrder> createOrder(CreateOrder value) {
    return new JAXBElement<Order>(_CreateOrder_QNAME, CreateOrder.class, null, value);
}
----

And the corresponding configuration in the switchyard.xml file:

image::switchyard/transformers/jaxb_transformer_switchyard_xml.png[JAXB transformers defined in switchyard.xml file]


== SwitchYard - Transformations - JSON

The JSON transformer provides a basic mapping facility between POJOs and JSON (JSON marshalling and unmarshalling). The JSON specification of the transformer requires a to and from specification with one Java type and one QNamed JSON type, depending on whether you're performing a Java to JSON or JSON to Java transformation.

[source,java]
----
<transforms>
   <xform:transform.json from="java:org.switchyard.quickstarts.transform.json.OrderAck" 
                         to="{urn:switchyard-quickstart:transform-json:1.0}orderResponse"/>
   <xform:transform.json from="{urn:switchyard-quickstart:transform-json:1.0}order" 
                         to="java:org.switchyard.quickstarts.transform.json.Order"/>
</transforms>
----

== SwitchYard - Transformations - Smooks

There are three distinct transformation models available with Smooks in SwitchYard:

1. XML to Java :  Based on a standard Smooks Java Binding configuration.
2. Java to XML:   Based on a standard Smooks Java Binding configuration.
3. Smooks :  This is a "normal" Smooks transformation in which the developer must define which Smooks filtering Result is to be exported back to the SwitchYard Message as the transformation result.

Smooks transformations are declared by including a <transform.smooks> definition in switchyard.xml.

[source,xml]
----
<transform.smooks config="/smooks/OrderAck_XML.xml"
                  from="java:org.switchyard.quickstarts.transform.smooks.OrderAck"
                  to="{urn:switchyard-quickstart:transform-smooks:1.0}submitOrderResponse"
                  type="JAVA2XML"/>
----
The config attribute points to a Smooks resource containing the mapping definition.  The type attribute can be one of SMOOKS, XML2JAVA, or JAVA2XML.

== SwitchYard - Transformations - XSLT

The XSLT transformer allows you to perform a transformation between 2 XML types, using an XSLT. It is configured simply by specifying the to and from QNames, as well as the path to the XSLT to be applied.

[source,xml]
----
<transforms>
   <transform.xslt xmlns="urn:switchyard-config:transform:1.0" 
                   from="{urn:switchyard-quickstart:transform-xslt:1.0}order" 
                   to="{urn:switchyard-quickstart:transform-xslt:1.0}orderAck" 
                   xsltFile="xslt/order.xslt"/>
</transforms>
----

And an xslt file is requierd for transformation:
[source,xml]
----
<?xml version="1.0"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	version="1.0">
	<xsl:template match="/">
		<orders:orderAck xmlns:orders="urn:switchyard-quickstart:transform-xslt:1.0">
			<xsl:for-each select="orders:order">
				<orderId>
					<xsl:value-of select="orderId" />
				</orderId>
				<accepted>
					<xsl:choose>
						<xsl:when test="(itemId = 'BUTTER') and (quantity &lt;= 200)">
							true
						</xsl:when>
						<xsl:otherwise>
							false
						</xsl:otherwise>
					</xsl:choose>
				</accepted>
				<status>
					<xsl:choose>
						<xsl:when test="(itemId = 'BUTTER') and (quantity &lt;= 200)">
							Order Accepted
						</xsl:when>
						<xsl:when test="itemId != 'BUTTER'">
							No Such Item:
							<xsl:value-of select="itemId" />
						</xsl:when>
						<xsl:when test="quantity &gt; 200">
							Not Enough Stock
						</xsl:when>
						<xsl:otherwise>
							UNKNOWN
						</xsl:otherwise>
					</xsl:choose>
				</status>
			</xsl:for-each>
		</orders:orderAck>
	</xsl:template>
</xsl:stylesheet>
----


== SwitchYard - Transformations - Transformations in a Camel component

Transformations can be done in Camel component. Camel provides with many means of doing tranformations: 

=== XSLT

[source,java]
----
   public void configure() throws Exception {
      from("direct:start")
            .to("xslt:book.xslt");
   }
----

==== XQuery

[source,java]
----
   public void configure() throws Exception {
      from("direct:start")
         .transform(xquery("<books>{for $x in /bookstore/book where $x/price>30 order by $x/title return $x/title}</books>"));
   }
----

=== JAXB

[source,java]
----
    public void configure() throws Exception {
        DataFormat myJaxb = new JaxbDataFormat("org.camelcookbook.transformation.myschema");

        from("direct:marshal")
            .marshal(myJaxb)
            .to("mock:marshalResult");

        from("direct:unmarshal")
            .unmarshal(myJaxb)
            .to("mock:unmarshalResult");
    }
----

=== JSON

[source,java]
----
    public void configure() throws Exception {
        from("direct:marshal")
            .marshal().json()
            .to("mock:marshalResult");

        from("direct:unmarshal")
            .unmarshal().json()
            .to("mock:unmarshalResult");
    }
----

=== XMLJSON

[source,java]
----
    public void configure() throws Exception {
        from("direct:marshal")
            .marshal().xmljson()
            .to("mock:marshalResult");

        from("direct:unmarshal")
            .unmarshal().xmljson()
            .to("mock:unmarshalResult");

        XmlJsonDataFormat xmlJsonFormat = new XmlJsonDataFormat();
        xmlJsonFormat.setRootName("bookstore");
        xmlJsonFormat.setElementName("book");
        xmlJsonFormat.setExpandableProperties(Arrays.asList("author", "author"));

        from("direct:unmarshalBookstore")
            .unmarshal(xmlJsonFormat)
            .to("mock:unmarshalBookstoreResult");
    }
----

See https://github.com/CamelCookbook/camel-cookbook-examples/tree/master/camel-cookbook-transformation[Camel developer cookbook Transformation Chapter source code]

== SwitchYard - Transformations - Transformations in a Camel component (II)
Transformations can be done in a variety of ways in camel:

[width="100%", cols="asciidoc,"]
|=======
|http://camel.apache.org/content-enricher.html[Content Enricher EIP] |image:transformers/ContentEnricher.gif[Content Enricher EIP]
|http://camel.apache.org/message-translator.html[Message Translator EIP] |image:transformers/MessageTranslator.gif[Message Translator EIP]
|http://camel.apache.org/content-filter.html[Content Filter EIP] |image:transformers/ContentFilter.gif[Content Filter EIP]
|http://camel.apache.org/normalizer.html[Normalizer EIP] |image:transformers/Normalizer.gif[Normalizer EIP]
|http://camel.apache.org/templating.html[Templating]|
|=======


== SwitchYard - Transformations - Other

 TODO: Create this

== SwitchYard - Validations (Java validations, XML Validation)
Validation feature provides a functionality for message content validation.

* Different implementations for validators:
** Java
** XML
** Other (to be coming...)

We often need to perform message validation before processing its data in service logic, but implementing the validation logic directly in the consumer or provider pollutes the service logic and can lead to tight coupling.  SwitchYard allows for the validation logic to be declared outside the service logic and injected into the mediation layer at runtime.

Validation of message content is specified in the descriptor of your SwitchYard application (switchyard.xml). The qualified name of the type being validated name is defined along with the validator implementation.

== SwitchYard - Java validations

Implementing Java validation is just a matter of creating a new (Java) Validator on the SwitchYard application:

image::switchyard/validators/new_validator.png[New validator]

And selecting type you want to validate and implementing class or bean.

image::switchyard/validators/java_validator.png[Create a Java validator]

It will create the appropiate configuration in the switchyard.xml file:

image::switchyard/validators/validator_switchyard_xml.png[Validator defined in switchyard.xml file]

And the appropiate class/bean needs to be created (manually), with the correspongin annotations (*@Named* and *@Validator*):

image::switchyard/validators/annotated_validator.png[Annotated validator]

Validation methods should return an instance of *import org.switchyard.validate.ValidationResult*.

There is a helper class for validation called: *org.switchyard.validate.BaseValidator* that provides with methods for *validResult()* and *invalidResult(...)*

== SwitchYard - XML validations

 TODO: Create this

== SwitchYard - Properties

 TODO: Create this

== SwitchYard - Environment Properties

Environment properties allow you to replace any attribute or element value in switchyard.xml with a property from the runtime environment. The syntax for a replaced token is "${varName}" where "varname" is your property name. The configuration layer in SwitchYard is configured with instances of PropertyResolver, which are used to resolve the value of a property based on its name.

=== Where to define Environment Properties
Property values are resolved from the following locations:

* System properties passed by -D option of Java VM like "-Dproperty.name=property.value"
* System environment variables, referenced with an "env." prefix, for example: env.PATH
* Unit test properties
* JBoss AS7 properties, including access into the SecurityVault
* Domain properties in switchyard.xml
* SCA property definitions in the composite or component

=== Property overriding
SwitchYard property resolver scans the property in following order.

* System properties and System environment variables
* Unit test properties
* JBoss AS7 properties
* Domain properties
* SCA composite properties
* SCA component properties

 You can specify the default property value with "${propertyName:defaultValue}" syntax where "propertyName" is the name of property.

=== Property escaping
Sometimes, the desired value for a property needs to be in the same "dollar curly" syntax which triggers SwitchYard's property substitution. This can be problematic because in these cases, you want SwitchYard to leave the configured value alone. To accomplish this, use a "double dollar curly" syntax instead.

[source,xml]
----
<foo value="${prop}"/>
<bar value="$${prop}"/>
----

Assuming the value "prop" is a resolvable property (say, equal to "test"), the value attribute of the foo element will be that value ("test").  However, the value attribute of the bar element will be "${test}" (with one dollar sign).

== SwitchYard - Implementation Properties
Implementation properties allow you to inject one or more property values into a service implementation.

This is based on the property support in the SCA assembly spec. Since the property is injected into service implementation logic, the injection mechanism itself is unique to each implementation type. 

* *Java*: injected using @Property into a CDI bean
* *Camel*: wired into Camel properties component and accessible in a Camel route using Camel's own varName property notation
* *BPEL*: mapped into process variables via an <assign> with using resolveProperty() XPath custom function
* *BPMN 2*: inserted into process variables by data input associations
* *Drools*: available in a global map

 TODO: Create this

== SwitchYard - Implementation Properties - Bean
Implementation properties represent environmental properties that you have defined in the SwitchYard application descriptor (switchyard.xml) for your bean implementation.  To access these properties, simply add an @Property annotation to your bean class identifying the property you want to inject. The following example demonstrates injection of a "user.name" property:

[source,java]
----
@Service(SimpleService.class)
public class SimpleServiceBean implements SimpleService {
 
   @Property(name="user.name")
   private String name;
 
   public String sayHello(String message) {
      return "Hello " + name + ", I got a message: " + message;
   }
}
----

== SwitchYard - Implementation Properties - Camel
SwitchYard integrates with the Properties Component in Camel to make system and application properties available inside your route definitions. You can inject properties into your camel route using "{{propertyName}}" expression where "propertyName" is the name of the property.

[source,xml]
----
<route xmlns="http://camel.apache.org/schema/spring" id="CamelTestRoute">
   <log message="ItemId [${body}]"/>
   <to uri="switchyard://WarehouseService?operationName=hasItem"/>
   <log message="Title Name [${body}]"/>
   <log message="Properties [{{user.name}}]"/>
</route>
----

== SwitchYard - Invocation Properties
It is information relative to the invocation or current execution. It is carried along the SwitchYard Context.

== SwitchYard - Invocation Properties - Bean Components
There can be situations where you need to access contextual information like message headers (e.g. received file name) in your implementation. To facilitate this, the Bean component allows you to access the SwitchYard Exchange Context instance associated with a given Bean Service Operation invocation. To get a reference to the Context, simply add a Context property to your bean and annotate it with the CDI @Inject annotation.

[source,java]
----
@Service(SimpleService.class)
public class SimpleServiceBean implements SimpleService {
 
@Inject
private Context context;
 
public String sayHello(String message) {
        System.out.println("*** Funky Context Property Value: " + context.getPropertyValue("funkyContextProperty"));
        return "Hi there!!";
    }
}
----

 The Context interface allows your bean logic to get and set properties in the context.  Note that you can only make calls on the Context instance within the scope of one of the Service Operation methods. Invoking it outside this scope will result in an UnsupportedOperationException being thrown.

== SwitchYard - Policies (transaction, )
Policy allows you to control the runtime behavior of a service in a declarative manner, independent of the service implementation and binding details. 

* Configuring policy
* Interaction Policy
* Implementation Policy

 TODO: Create this

== Transaction Policy

 TODO: Create this

== Transaction Interaction Policy

 TODO: Create this

== Transaction Implementation Policy

 TODO: Create this

== Security Policy

 TODO: Create this

== Security Interaction Policy

 TODO: Create this

== Security Implementation Policy

 TODO: Create this

== SwitchYard - Security
SwitchYard services can be secured by:

1. Specifying a list of security policies that are required for that service.
2. Configuring application-level security processing details for the services within a domain.
3. Configuring system-level security processing details.
4. Storing sensitive information, such as passwords, in the JBoss AS password vault.

 TODO: Create this

== SwitchYard - Clustering
There are two fundamental building blocks to the clustering support in SwitchYard:

* *Shared Runtime Registry*: a shared, distributed runtime registry which allows individual instances to publish and query service endpoint details.
* *Remote Communication Channels*: an internal communication protocol used to allow a service client to invoke a service hosted in a remote instance.

image::switchyard/clustering.jpg[Clustering]

The runtime registry is backed by a replicated Infinispan cache.  Each instance in a cluster points to the same replicated cache.  When a node joins a cluster, it immediately has access to all remote service endpoints published in the registry.  If a node leaves the cluster due to failure or shutdown, all service endpoint registrations are immediately removed for that node.  The registry is not persisted, so manually clean-up and maintenance is not required.  Note that the shared registry is a runtime registry and not a publication registry, which means the registry's lifecycle and state is tied to the current state of deployed services within a cluster.  This is in contrast to a publication registry (e.g. UDDI), where published endpoints are independent from the runtime state of the ESB.

The communications channel is a private intra-cluster protocol used by instances to invoke a remote service.  The channel is currently based on HTTP, but this may change in the future and should be considered a transparent detail of the clustering support in SwitchYard.

 TODO: REVIEW this

== SwitchYard - Configuring Clustering
Clustering support is light on configuration and should work out of the box.  The only real requirements are using a shared Infinispan cache for the runtime registry and indicating which services are clustered in your application config (switchyard.xml).  By default, SwitchYard uses the default cache in the "cluster" cache container which comes pre-defined in your standalone-ha.xml.  Unless you have specific requirements to use a different cache or separate cache configuration, just stick with the default.

Applications take advantage of clustering by explicitly identifying which services should be clustered in the application's descriptor (switchyard.xml).  You can control which services in your application will be published in the cluster's runtime registry and which references can be resolved by clustered services.  To enable a service to be published in the cluster's runtime registry, promote the service in your application and add a <binding.sca> with clustering enabled to it.

[source,xml]
----
<sca:service name="Goodbye" promote="GoodbyeBean/Goodbye">   
   <sca:interface.java interface="com.example.Goodbye"/>
   <sca:binding.sca sy:clustered="true"/>
</sca:service>
----

Consuming services in a cluster follows the same configuration approach, but applies to references in your application.  To invoke a service in a cluster, promote the reference and add an SCA binding with clustering enabled.

[source,xml]
----
<sca:reference name="Goodbye" multiplicity="0..1" promote="GreetingBean/Goodbye">
   <sca:interface.java interface="com.example.Goodbye"/>
   <sca:binding.sca sy:clustered="true"
</sca:reference>
----

 TODO: REVIEW this

== SwitchYard - Using Clustering
To create a cluster of SwitchYard instances, start two or more AS 7 instances with a shared Infinispan cache.  Out-of-the-box configuration in standalone-ha.xml should be sufficient:

[source,bash]
----
# start instance 1
node1> bin/standalone.sh -c standalone-ha.xml -Djboss.node.name=node1
# start instance 2
node2> bin/standalone.sh -c standalone-ha.xml -Djboss.node.name=node2 -Djboss.socket.binding.port-offset=1000
----

Once the instances are up, you can deploy applications independently to each instance.  A homogeneous cluster would have identical applications deployed on each node.  A heterogeneous cluster will have different applications and services deployed on each instance. For testing purposes, it's easiest to deploy a consumer application to one instance and a provider application to another.

 TODO: REVIEW this

== SwitchYard - RemoteInvoker

 TODO: Create this

== SwitchYard - Serialization

 TODO: Create this

== SwitchYard - Extensions

 TODO: Create this

== SwitchYard - Use cases:
 * Asynchronous processing: How to build, deploy, and manage a simple Camel route that communicates with ActiveMQ queues
 * Synchronous processing: How to build, deploy, and manage a simple service

 TODO: Create this

== SwitchYard - Debugging an application
 * Message tracing
 * Exchange interceptors
 * Auditing exchanges

 TODO: Create this

== SwitchYard - Testing SwitchYard application
Switchyard testing capabilities rely on JUnit4.

* SwitchYardRunner
* SwitchYardTestKit
* SwitchYardTestCaseConfig

 TODO: Create this

== SwitchYard - Testing - SwitchYardRunner

 TODO: Create this

== SwitchYard - Testing - SwitchYardTestKit

 TODO: Create this

== SwitchYard - Testing - SwitchYardTestCaseConfig

* config
* mixins
* scanner

 TODO: Create this

== SwitchYard - Testing - MixIns

* CDIMixIn
* HTTPMixIn
* SmooksMixIn
* HornetQMixIn
* JCAMixIn
* NamingMixIn
* PropertyMixIn
 
 TODO: Create this

== SwitchYard - Testing - Scanners

* *BeanSwitchYardScanner*: Scans for CDI Bean Service implementations.
* *TransformSwitchYardScanner*: Scans for Transformers.
* *BpmSwitchYardScanner*: Scans for @Process, @StartProcess, @SignalEvent and @AbortProcessInstance annotations.
* *RouteScanner*: Scans for Camel Routes.
* *RulesSwitchYardScanner*: Scans for @Rule annotations.
  
 TODO: Create this

== SwitchYard - Testing - Metadata and support injection
  
* TestKit Injection
* Deployment Injection
* SwitchYardModel Injection
* ServiceDomain Injection
* TransformerRegistry Injection
* TestMixIn Injection
* PropertyMixIn Injection
* Invoker Injection
 TODO: Create this

== SwitchYard - Advanced topics
 * Creating your own camel endpoint/component (Extensions)
 * Distributed transactions in FSW - what is possible and what is not possible (e.g. can a splitter/aggregator ever be transactional)

 TODO: Create this

== RTGov

For call trace
* ActivityReporter: reports activity to the BAM server. Can be injected with @Inject in a Bean Component. (How can be injected in Camel or any other???) Has methods logError, logWarn, logInfo,...

For policies:
* AbstractExchangeValidator extends ExchangeInterceptor: This class observes exchanges and uses the information to create activity events to be validated
* ExchangeInterceptors allow code to be injected around specific interactions in the core exchange bus via a target definition. Valid targets are documented as constant fields in this interface

InformationProcessor that is based on a set of expressions used to extract relevant data from the supplied information.

 TODO: Create this


== DTGov

 * App building
 * life-cycle management
 * Deployment
 * Integrating the build/test/deployment process into a maven based build engine

 TODO: Create this

== Development
 
 * JBoss Developer Studio + IS plugins
 * Maven
 * Project structure (single project, multiproject, war, ear,...)

 TODO: Create this


== Operations
 
 * Installation (installer, silent,...)
 * Starting/stopping servers (server services)
 * Users
 * Multinode configuration (Multiple servers in one box
 * Databases
 * Management (Console, CLI, JMX, BPEL Console)
 * Monitoring
 * Troubleshooting

 TODO: Create this

== Thank you

That's all.

