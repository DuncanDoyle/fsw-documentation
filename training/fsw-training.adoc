FSW Training
============
:author: Jorge Morales 
:email: <jmorales@redhat.com>
:description: FSW training
:revdate: 2014-07-17
:revnumber: 0.1
:icons: font
:imagesdir: ./images
:deckjs_theme: web-2.0
:deckjs_transition: horizontal-slide
//:pygments:
//:pygments_style: native
:scrollable:
//:linkcss:
//:count_nested:

== Contents

* SwitchYard
* RTGov
* DTGov

== SwitchYard

[width="100%", cols=",asciidoc"]
|=======
| image:switchyard.png[] | * SCA (Service, component, reference, binding)
 * Components (Service implementations)
 * Bindings (Gateways)
 * Transformations (Java, JAXB, JSON, Smooks, XSLT, ...)
 * Validations (Java validations, XML Validation)
 * Properties
 * Policies (transaction, )
 * Security
 * Clustering
 * RemoteInvoker
 * Serialization
 * Extensions 
|=======

== SwitchYard - SCA

 SwitchYard is a component-based development framework focused on building structured, maintainable services and applications using the concepts and best practices of SOA. It works with Apache Camel to provide a fast, simple, flexible integration runtime with comprehensive connectivity and transports. A uniform application model augments Apache Camel, joining Java EE, BPM, rules, orchestration, and routing into a cohesive development model and runtime. Common functionality and cross-cutting concerns - validation, transformation and policy - are isolated from business logic and handled declaratively. This ensures consistency and eliminates duplication, offering developers a clear view of the structure and relationships of services in an integration application.

image::app.jpg[SwitchYard application]

== Composite
A composite is displayed as a light blue rectangle and represents the boundary between what's inside your application and what's outside your application. A SwitchYard application consists of exactly one composite that has a name and a targetNamespace. The targetNamespace value is important as it allows names defined locally in the application (e.g. service names) to be qualified and unique within a SwitchYard runtime.

image::composite.jpg[composite]

[source,xml]
----
<sca:composite name="example" targetNamespace="urn:example:switchyard:1.0">
</sca:composite>
----

== Component
A component is a modular container for application logic and consists of the following:

* 0 or 1 component service definitions
* 0 to many component reference definitions
* 1 implementation

Services and references allow a component to interact with other components, while the implementation provides the actual logic for providing and/or consuming services.

image::component.jpg[component]

[source,xml]
----
<sca:component name="Routing">
</sca:component>
----

== Implementation
An implementation acts as the 'brain' of a service component and it is how implement your application logic. The following implementation options are available:

* *Bean*: allows a CDI Bean to consume or provide services using annotations.
* *Camel*: EIP-style routing and service composition using the XML or Java DSL in Apache Camel.
* *BPMN 2*: service orchestration and human task integration expressed as BPMN 2 and executed using jBPM.
* *BPEL Process*: web service orchestration using the OASIS Business Process Execution Language.
* *Rules*: decision services based on Drools.

Implementations are private to a component, which means external consumers and providers are not aware of the details of a component's implementation (implementation-hiding).  All interactions with other components within an application and with external services are handled through component services and references.

image::implementations.jpg[implementation]

[source,xml]
----
<sca:component name="Routing">
   <camel:implementation.camel>
      <camel:xml path="RoutingService.xml"/>
   </camel:implementation.camel>
</sca:component>
----

== Component Service
A component service is used to expose the functionality of an implementation as a service. All component services have a contract, which can be a Java interface, WSDL portType definition, or a set of named data types (interface.esb). Component services are private to an application, which means a component service can only be invoked by other components in the same application. In order to expose a component service to consumers external to the application, a component service can be 'promoted' to a composite service. A component service can be promoted multiple times to create different composite services.

image::component-service.jpg[Component service]

[source,xml]
----
<sca:component name="Routing">
   <camel:implementation.camel>
      <camel:xml path="route.xml"/>
   </camel:implementation.camel>
   <sca:service name="ServiceA">
      <sca:interface.java interface="org.example.ServiceA"/>
   </sca:service>
</sca:component>
----

== Composite Service
A composite service represents an application service which is visible to other applications. A composite service can only be realized by promoting a component service within the application. The name and the interface of the composite service can be different from the component service. If the interface, or contract, of the composite service is different from the component service, be aware that a transformation may be required to map between the types defined in each interface. In our example application, the component service has a Java interface while the composite service has a WSDL interface. This means we would need to declare a transformer which maps between XML and Java to resolve the data type mismatch.

image::composite-service.jpg[Composite service]

[source,xml]
----
<sca:composite name="example" targetNamespace="urn:example:switchyard:1.0">
   <sca:service name="ServiceA" promote="Routing/ServiceA">
      <sca:interface.wsdl interface="ServiceA.wsdl#wsdl.porttype(ServiceAPortType)"/>
   </sca:service>
</sca:composite>
----

== Service Binding
A service binding is used to define an access method for a composite service. Composite services can have multiple bindings, which allows a single service to be accessed in different ways. In most cases, a service binding represents a protocol/transport adapter (e.g. SOAP, JMS, REST). An important exception to this rule is the SCA binding, which allows services across applications in the same runtime to be wired together in memory. Regardless of the underlying binding details, a binding must always be used to facilitate inter-application communication in SwitchYard.

image::service-binding.jpg[Service binding]

[source,xml]
----
<sca:composite name="example" targetNamespace="urn:example:switchyard:1.0">
   <sca:service name="ServiceA" promote="Routing/ServiceA">
      <sca:interface.wsdl interface="ServiceA.wsdl#wsdl.porttype(ServiceAPortType)"/>
      <soap:binding.soap>
        <soap:wsdl>ServiceA.wsdl</soap:wsdl>
      </soap:binding.soap>
   </sca:service>
</sca:composite>
----

== Component Reference
A component reference allows a component to consume other services. A component reference can be wired to a service offered by another component in the same application or it can be wired to services outside the application via a composite reference. Similar to component services, all component references have a contract with allows a component to invoke services without knowing implementation or binding details. The picture below shows an example of wiring a reference on the Routing component to a service offered by the Bean component.

image::component-reference.jpg[Component reference]

[source,xml]
----
<sca:component name="Routing">
   <camel:implementation.camel>
      <camel:xml path="route.xml"/>
   </camel:implementation.camel>
   <sca:service name="ServiceA">
      <sca:interface.java interface="org.example.ServiceA"/>
   </sca:service>
   <sca:reference name="ServiceC">
      <sca:interface.java interface="org.example.ServiceC"/>
   </sca:reference>
</sca:component>
----

== Composite Reference
A composite reference allows a component reference to be wired to a service outside the application. Similar to composite services, bindings are used with composite references to specify the communication method for invoking the external service.

image::composite-reference.jpg[Composite reference]

[source,xml]
----
<sca:composite name="example" targetNamespace="urn:example:switchyard:1.0">
   <sca:reference name="ReferenceB" multiplicity="0..1" promote="Routing/ServiceB">
      <sca:interface.java interface="org.example.ServiceB"/>
   </sca:reference>
</sca:composite>
----

== Reference Bindings
A reference binding is used to define an access method for an external service via a composite reference. Unlike service bindings, there can only be one binding for each composite reference. The set of bindings available for references is identical to the set of bindings available for services, although the configuration values for a given binding may be different depending on whether it's used as a service binding or a reference binding.

image::reference-binding.jpg[Reference binding]

[source,xml]
----
<sca:composite name="example" targetNamespace="urn:example:switchyard:1.0">
   <sca:reference name="ReferenceB" multiplicity="0..1" promote="Routing/ServiceB">
      <sca:interface.java interface="org.example.ServiceB"/>
         <jms:binding.jms>
         <jms:queue>MyQueue</jms:queue>
         <jms:connectionFactory>#ConnectionFactory</jms:connectionFactory>
      </jms:binding.jms>
   </sca:reference>
</sca:composite>
----

== Switchyard - Components
 **  Interfaces: wsdl, java, esb
 **  Bean (Java)
 **  Camel (java, xml)
 **  BPEL (XPath functions)
 **  BPM
 **  Rules (Knowledge services)

== Switchyard - Interfaces

 TODO: Create this

== Switchyard - Bean Component

 TODO: Create this

== Switchyard - Camel Component

 TODO: Create this

== Switchyard - BPEL Component

 TODO: Create this

== Switchyard - BPM Component

 TODO: Create this

== Switchyard - Rules Component

 TODO: Create this

== Switchyard - Binding/Gateways
 ** Http based
 ***  SOAP
 ***  RESTEasy
 ***  HTTP
 ** Camel based
 *** JPA
 *** JCA
 *** JMS
 *** SQL
 *** File
 *** FTP FTPS SFTP
 *** TCP UDP
 *** Quartz
 *** Timer
 *** SEDA
 ** SCA
 ** Camel URI*
 ** MessageComposers/MessageContext
 ** Operation selection
 ** Throttling

== Switchyard - SOAP Binding

 TODO: Create this

== Switchyard - RESTEasy Binding

 TODO: Create this

== Switchyard - HTTP Binding

 TODO: Create this

== Switchyard - JPA Binding

 TODO: Create this

== Switchyard - JCA Binding

 TODO: Create this

== Switchyard - JMS Binding

 TODO: Create this

== Switchyard - SQL Binding

 TODO: Create this

== Switchyard - File Binding

 TODO: Create this

== Switchyard - FTP FTPS SFTP Binding

 TODO: Create this

== Switchyard - TCP UDP Binding

 TODO: Create this

== Switchyard - Quartz Binding

 TODO: Create this

== Switchyard - Timer Binding

 TODO: Create this

== Switchyard - SEDA Binding

 TODO: Create this

== Switchyard - SCA Binding

 TODO: Create this

== Switchyard - Camel URI Binding

 TODO: Create this

== Switchyard - Message Composers

 TODO: Create this

== Switchyard - Operation selection

 TODO: Create this

== Switchyard - Throttling

 TODO: Create this

== SwitchYard - Transformations (Java, JAXB, JSON, Smooks, XSLT, ...)

When is a transformation required:

 When origin type and destination type of a "wire connection" is not of the same type, and implicit type conversion (provided by Camel type converters) can not convert between both types.

 Declarative transformation only kicks in when the runtime detects that the message type is different between the consumer and provider contracts.

The tooling reflects this as well, which is why if there are no interactions where contract types differ, then you cannot create a transformer. There are three scenarios in SY where the contract types can differ and require a transformation:
 
1. A composite service interface is different from the component service interface it promotes.
2. A component reference interface is different from the component service interface it is wired to.
3. A composite reference interface is different from the component reference interface it promotes.

* Different implementations for transformations:
** Java
** JAXB
** JSON
** Smooks
** XSLT
** Transformations in a Camel component
** Other (coming next: Dozer,...)

== SwitchYard - Transformations - Content Type Names

Since transformations occur between named types (i.e. from type A, to type B), it's important to understand how the type names are derived. The type of the message is determined based on the service contract, which can be WSDL or Java.

For WSDL interfaces, the message name is determined based on the fully-qualified element name of a WSDL message.  Take the following WSDL definition:

[source,xml]
----
<definitions xmlns:tns="urn:switchyard-quickstart:bean-service:1.0">  
  <message name="submitOrder">
    <part name="parameters" element="tns:submitOrder"/>
  </message>
  <portType name="OrderService">
    <operation name="submitOrder">
      <input message="tns:submitOrder"/>
    </operation>
  </portType>
</definitions>
----

This would yield the following message type name based on the message element name defined in the WSDL:

[source,java]
----
{urn:switchyard-quickstart:bean-service:1.0}submitOrder
----

When Java interfaces are used for the service contract, the message name consists of the full package name + the class name, prefixed with "java:".

[source,java]
----
package org.switchyard.example;
public interface OrderService {
    void submitOrder(Order order);
}
----

The message type name for the submitOrder method in this Java interface would be *"java:org.switchyard.example.Order"*.  

Occasionally, it can be useful to override the default operation name generated for a Java interface. The *@OperationTypes* annotation provides this capability by allowing the user to specify the input, output, and/or fault type names used for a Java service interface. 

For example, if we wanted to accept XML input content without any need for transformation to a Java object model, the OrderService interface could be changed to look like this:

[source,java]
----
package org.switchyard.example;
public interface OrderService {
    @OperationTypes(in = "{urn:switchyard-quickstart:bean-service:1.0}submitOrder")
    void submitOrder(String orderXML);
}
----

Aside from short-circuiting the requirement for transformation, this annotation can be useful if you want to maintain tight control over the names used for message content.

== SwitchYard - Transformations

Required transformations are automatically detected by IDE, but, if missing, can be created/deleted/recreated manually:

image::transformers/no_missing_transformer.png[All required validators have been added]

If you remove all/any of the transformers, you will be able to create missing required transformers:

image::transformers/required_transformers.png[Create required transformer]

A new dialog will let you create a new transformer:

image::transformers/new_transformer_all.png[New Transformer]

== SwitchYard - Transformations - Java
Java transformer let you do any kind of transformation using Java for this purpose. There are two methods available for creating a Java-based transformer in SwitchYard:

1. Implement the *org.switchyard.transform.Transfomer* interface and add a *<transform.java>* definition to your switchyard.xml.
2. Annotate one or more methods on your Java class with *@Transformer*.

 When using the @Transformer annotation, the SwitchYard maven plugin will automatically generate the <transform.java> definition(s) for you and add them to the switchyard.xml packaged in your application.

Implementing Java transformations is just a matter of creating a new (Java) Transformer on the SwitchYard application:

image::transformers/new_transformer.png[New validator]

And selecting Java as the type of transformer you want implementing class or bean.

image::transformers/new_java_transformer.png[Create a Java transformer]

It will create the appropiate transformer class/bean with the default annotated methods:

image::transformers/java_transformer.png[Java Transformer class]

 The optional from and to elements of the @Transformer annotation can be used to specify the qualified type name used during transformer registration.  If not supplied, the full class name of the method parameter will be used as the from type and the full class name of the return type will be used as the to type.

And the corresponding configuration in the switchyard.xml file:

image::transformers/transformer_switchyard_xml.png[Transformers defined in switchyard.xml file]

 The CDI bean name specified by @Named annotation is used to resolve transformer class. If you don't specify, then class name of the transformer is used instead.

== SwitchYard - Transformations - JAXB

The JAXB transformer allows you to perform Java to XML (and XML to Java) transformations using JAXB (XML marshalling and unmarshalling).

 JAXB Java models can be generated from an XML Schema using XJC, or from a WSDL using tools like wsconsume, or from within JBDS IDE with "JAXB`s JAXB classes from Schema" or "SwitchYard`s Java Files from WSDL".

JAXB Transformer requires a *to* and *from* with one Java type and one QNamed XML type, depending on whether you're performing a Java to XML or XML to Java transformation.

[source,java]
----
@XmlElementDecl(namespace = "http://com.acme/orders", name = "create")
public JAXBElement<CreateOrder> createOrder(CreateOrder value) {
    return new JAXBElement<Order>(_CreateOrder_QNAME, CreateOrder.class, null, value);
}
----

And the corresponding configuration in the switchyard.xml file:

image::transformers/jaxb_transformer_switchyard_xml.png[JAXB transformers defined in switchyard.xml file]


== SwitchYard - Transformations - JSON

The JSON transformer provides a basic mapping facility between POJOs and JSON (JSON marshalling and unmarshalling). The JSON specification of the transformer requires a to and from specification with one Java type and one QNamed JSON type, depending on whether you're performing a Java to JSON or JSON to Java transformation.

[source,java]
----
<transforms>
   <xform:transform.json from="java:org.switchyard.quickstarts.transform.json.OrderAck" 
                         to="{urn:switchyard-quickstart:transform-json:1.0}orderResponse"/>
   <xform:transform.json from="{urn:switchyard-quickstart:transform-json:1.0}order" 
                         to="java:org.switchyard.quickstarts.transform.json.Order"/>
</transforms>
----

== SwitchYard - Transformations - Smooks

There are three distinct transformation models available with Smooks in SwitchYard:

1. XML to Java :  Based on a standard Smooks Java Binding configuration.
2. Java to XML:   Based on a standard Smooks Java Binding configuration.
3. Smooks :  This is a "normal" Smooks transformation in which the developer must define which Smooks filtering Result is to be exported back to the SwitchYard Message as the transformation result.

Smooks transformations are declared by including a <transform.smooks> definition in switchyard.xml.

[source,xml]
----
<transform.smooks config="/smooks/OrderAck_XML.xml"
                  from="java:org.switchyard.quickstarts.transform.smooks.OrderAck"
                  to="{urn:switchyard-quickstart:transform-smooks:1.0}submitOrderResponse"
                  type="JAVA2XML"/>
----
The config attribute points to a Smooks resource containing the mapping definition.  The type attribute can be one of SMOOKS, XML2JAVA, or JAVA2XML.

== SwitchYard - Transformations - XSLT

The XSLT transformer allows you to perform a transformation between 2 XML types, using an XSLT. It is configured simply by specifying the to and from QNames, as well as the path to the XSLT to be applied.

[source,xml]
----
<transforms>
   <transform.xslt xmlns="urn:switchyard-config:transform:1.0" 
                   from="{urn:switchyard-quickstart:transform-xslt:1.0}order" 
                   to="{urn:switchyard-quickstart:transform-xslt:1.0}orderAck" 
                   xsltFile="xslt/order.xslt"/>
</transforms>
----

And an xslt file is requierd for transformation:
[source,xml]
----
<?xml version="1.0"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	version="1.0">
	<xsl:template match="/">
		<orders:orderAck xmlns:orders="urn:switchyard-quickstart:transform-xslt:1.0">
			<xsl:for-each select="orders:order">
				<orderId>
					<xsl:value-of select="orderId" />
				</orderId>
				<accepted>
					<xsl:choose>
						<xsl:when test="(itemId = 'BUTTER') and (quantity &lt;= 200)">
							true
						</xsl:when>
						<xsl:otherwise>
							false
						</xsl:otherwise>
					</xsl:choose>
				</accepted>
				<status>
					<xsl:choose>
						<xsl:when test="(itemId = 'BUTTER') and (quantity &lt;= 200)">
							Order Accepted
						</xsl:when>
						<xsl:when test="itemId != 'BUTTER'">
							No Such Item:
							<xsl:value-of select="itemId" />
						</xsl:when>
						<xsl:when test="quantity &gt; 200">
							Not Enough Stock
						</xsl:when>
						<xsl:otherwise>
							UNKNOWN
						</xsl:otherwise>
					</xsl:choose>
				</status>
			</xsl:for-each>
		</orders:orderAck>
	</xsl:template>
</xsl:stylesheet>
----


== SwitchYard - Transformations - Transformations in a Camel component

Transformations can be done in Camel component. Camel provides with many means of doing tranformations: 

=== XSLT

[source,java]
----
   public void configure() throws Exception {
      from("direct:start")
            .to("xslt:book.xslt");
   }
----

==== XQuery

[source,java]
----
   public void configure() throws Exception {
      from("direct:start")
         .transform(xquery("<books>{for $x in /bookstore/book where $x/price>30 order by $x/title return $x/title}</books>"));
   }
----

=== JAXB

[source,java]
----
    public void configure() throws Exception {
        DataFormat myJaxb = new JaxbDataFormat("org.camelcookbook.transformation.myschema");

        from("direct:marshal")
            .marshal(myJaxb)
            .to("mock:marshalResult");

        from("direct:unmarshal")
            .unmarshal(myJaxb)
            .to("mock:unmarshalResult");
    }
----

=== JSON

[source,java]
----
    public void configure() throws Exception {
        from("direct:marshal")
            .marshal().json()
            .to("mock:marshalResult");

        from("direct:unmarshal")
            .unmarshal().json()
            .to("mock:unmarshalResult");
    }
----

=== XMLJSON

[source,java]
----
    public void configure() throws Exception {
        from("direct:marshal")
            .marshal().xmljson()
            .to("mock:marshalResult");

        from("direct:unmarshal")
            .unmarshal().xmljson()
            .to("mock:unmarshalResult");

        XmlJsonDataFormat xmlJsonFormat = new XmlJsonDataFormat();
        xmlJsonFormat.setRootName("bookstore");
        xmlJsonFormat.setElementName("book");
        xmlJsonFormat.setExpandableProperties(Arrays.asList("author", "author"));

        from("direct:unmarshalBookstore")
            .unmarshal(xmlJsonFormat)
            .to("mock:unmarshalBookstoreResult");
    }
----

See https://github.com/CamelCookbook/camel-cookbook-examples/tree/master/camel-cookbook-transformation[Camel developer cookbook Transformation Chapter source code]

== SwitchYard - Transformations - Transformations in a Camel component (II)
Transformations can be done in a variety of ways in camel:

[width="100%", cols="asciidoc,"]
|=======
|http://camel.apache.org/content-enricher.html[Content Enricher EIP] |image:transformers/ContentEnricher.gif[Content Enricher EIP]
|http://camel.apache.org/message-translator.html[Message Translator EIP] |image:transformers/MessageTranslator.gif[Message Translator EIP]
|http://camel.apache.org/content-filter.html[Content Filter EIP] |image:transformers/ContentFilter.gif[Content Filter EIP]
|http://camel.apache.org/normalizer.html[Normalizer EIP] |image:transformers/Normalizer.gif[Normalizer EIP]
|http://camel.apache.org/templating.html[Templating]|
|=======


== SwitchYard - Transformations - Other

 TODO: Create this

== SwitchYard - Validations (Java validations, XML Validation)
Validation feature provides a functionality for message content validation.

* Different implementations for validators:
** Java
** XML
** Other (to be coming...)

We often need to perform message validation before processing its data in service logic, but implementing the validation logic directly in the consumer or provider pollutes the service logic and can lead to tight coupling.  SwitchYard allows for the validation logic to be declared outside the service logic and injected into the mediation layer at runtime.

Validation of message content is specified in the descriptor of your SwitchYard application (switchyard.xml). The qualified name of the type being validated name is defined along with the validator implementation.

== SwitchYard - Java validations

Implementing Java validation is just a matter of creating a new (Java) Validator on the SwitchYard application:

image::validators/new_validator.png[New validator]

And selecting type you want to validate and implementing class or bean.

image::validators/java_validator.png[Create a Java validator]

It will create the appropiate configuration in the switchyard.xml file:

image::validators/validator_switchyard_xml.png[Validator defined in switchyard.xml file]

And the appropiate class/bean needs to be created (manually), with the correspongin annotations (*@Named* and *@Validator*):

image::validators/annotated_validator.png[Annotated validator]

Validation methods should return an instance of *import org.switchyard.validate.ValidationResult*.

There is a helper class for validation called: *org.switchyard.validate.BaseValidator* that provides with methods for *validResult()* and *invalidResult(...)*

== SwitchYard - XML validations

 TODO: Create this

== SwitchYard - Properties

 TODO: Create this

== SwitchYard - Environment Properties

Environment properties allow you to replace any attribute or element value in switchyard.xml with a property from the runtime environment. The syntax for a replaced token is "${varName}" where "varname" is your property name. The configuration layer in SwitchYard is configured with instances of PropertyResolver, which are used to resolve the value of a property based on its name.

=== Where to define Environment Properties
Property values are resolved from the following locations:

* System properties passed by -D option of Java VM like "-Dproperty.name=property.value"
* System environment variables, referenced with an "env." prefix, for example: env.PATH
* Unit test properties
* JBoss AS7 properties, including access into the SecurityVault
* Domain properties in switchyard.xml
* SCA property definitions in the composite or component

=== Property overriding
SwitchYard property resolver scans the property in following order.

* System properties and System environment variables
* Unit test properties
* JBoss AS7 properties
* Domain properties
* SCA composite properties
* SCA component properties

 You can specify the default property value with "${propertyName:defaultValue}" syntax where "propertyName" is the name of property.

=== Property escaping
Sometimes, the desired value for a property needs to be in the same "dollar curly" syntax which triggers SwitchYard's property substitution. This can be problematic because in these cases, you want SwitchYard to leave the configured value alone. To accomplish this, use a "double dollar curly" syntax instead.

[source,xml]
----
<foo value="${prop}"/>
<bar value="$${prop}"/>
----

Assuming the value "prop" is a resolvable property (say, equal to "test"), the value attribute of the foo element will be that value ("test").  However, the value attribute of the bar element will be "${test}" (with one dollar sign).

== SwitchYard - Implementation Properties
Implementation properties allow you to inject one or more property values into a service implementation.

This is based on the property support in the SCA assembly spec. Since the property is injected into service implementation logic, the injection mechanism itself is unique to each implementation type. 

* *Java*: injected using @Property into a CDI bean
* *Camel*: wired into Camel properties component and accessible in a Camel route using Camel's own varName property notation
* *BPEL*: mapped into process variables via an <assign> with using resolveProperty() XPath custom function
* *BPMN 2*: inserted into process variables by data input associations
* *Drools*: available in a global map

 TODO: Create this


== SwitchYard - Policies (transaction, )
Policy allows you to control the runtime behavior of a service in a declarative manner, independent of the service implementation and binding details. 

* Configuring policy
* Interaction Policy
* Implementation Policy

 TODO: Create this

== Transaction Policy

 TODO: Create this

== Transaction Interaction Policy

 TODO: Create this

== Transaction Implementation Policy

 TODO: Create this

== Security Policy

 TODO: Create this

== Security Interaction Policy

 TODO: Create this

== Security Implementation Policy

 TODO: Create this

== SwitchYard - Security
SwitchYard services can be secured by:

1. Specifying a list of security policies that are required for that service.
2. Configuring application-level security processing details for the services within a domain.
3. Configuring system-level security processing details.
4. Storing sensitive information, such as passwords, in the JBoss AS password vault.

 TODO: Create this

== SwitchYard - Clustering
There are two fundamental building blocks to the clustering support in SwitchYard:

* *Shared Runtime Registry*: a shared, distributed runtime registry which allows individual instances to publish and query service endpoint details.
* *Remote Communication Channels*: an internal communication protocol used to allow a service client to invoke a service hosted in a remote instance.

image::clustering.jpg[Clustering]

The runtime registry is backed by a replicated Infinispan cache.  Each instance in a cluster points to the same replicated cache.  When a node joins a cluster, it immediately has access to all remote service endpoints published in the registry.  If a node leaves the cluster due to failure or shutdown, all service endpoint registrations are immediately removed for that node.  The registry is not persisted, so manually clean-up and maintenance is not required.  Note that the shared registry is a runtime registry and not a publication registry, which means the registry's lifecycle and state is tied to the current state of deployed services within a cluster.  This is in contrast to a publication registry (e.g. UDDI), where published endpoints are independent from the runtime state of the ESB.

The communications channel is a private intra-cluster protocol used by instances to invoke a remote service.  The channel is currently based on HTTP, but this may change in the future and should be considered a transparent detail of the clustering support in SwitchYard.

 TODO: REVIEW this

== SwitchYard - Configuring Clustering
Clustering support is light on configuration and should work out of the box.  The only real requirements are using a shared Infinispan cache for the runtime registry and indicating which services are clustered in your application config (switchyard.xml).  By default, SwitchYard uses the default cache in the "cluster" cache container which comes pre-defined in your standalone-ha.xml.  Unless you have specific requirements to use a different cache or separate cache configuration, just stick with the default.

Applications take advantage of clustering by explicitly identifying which services should be clustered in the application's descriptor (switchyard.xml).  You can control which services in your application will be published in the cluster's runtime registry and which references can be resolved by clustered services.  To enable a service to be published in the cluster's runtime registry, promote the service in your application and add a <binding.sca> with clustering enabled to it.

[source,xml]
----
<sca:service name="Goodbye" promote="GoodbyeBean/Goodbye">   
   <sca:interface.java interface="com.example.Goodbye"/>
   <sca:binding.sca sy:clustered="true"/>
</sca:service>
----

Consuming services in a cluster follows the same configuration approach, but applies to references in your application.  To invoke a service in a cluster, promote the reference and add an SCA binding with clustering enabled.

[source,xml]
----
<sca:reference name="Goodbye" multiplicity="0..1" promote="GreetingBean/Goodbye">
   <sca:interface.java interface="com.example.Goodbye"/>
   <sca:binding.sca sy:clustered="true"
</sca:reference>
----

 TODO: REVIEW this

== SwitchYard - Using Clustering
To create a cluster of SwitchYard instances, start two or more AS 7 instances with a shared Infinispan cache.  Out-of-the-box configuration in standalone-ha.xml should be sufficient:

[source]
----
# start instance 1
node1> bin/standalone.sh -c standalone-ha.xml -Djboss.node.name=node1
# start instance 2
node2> bin/standalone.sh -c standalone-ha.xml -Djboss.node.name=node2 -Djboss.socket.binding.port-offset=1000
----

Once the instances are up, you can deploy applications independently to each instance.  A homogeneous cluster would have identical applications deployed on each node.  A heterogeneous cluster will have different applications and services deployed on each instance. For testing purposes, it's easiest to deploy a consumer application to one instance and a provider application to another.

 TODO: REVIEW this

== SwitchYard - RemoteInvoker

 TODO: Create this

== SwitchYard - Serialization

 TODO: Create this

== SwitchYard - Extensions

 TODO: Create this

== SwitchYard - Use cases:
 * Asynchronous processing: How to build, deploy, and manage a simple Camel route that communicates with ActiveMQ queues
 * Synchronous processing: How to build, deploy, and manage a simple service

 TODO: Create this

== SwitchYard - Debugging an application
 * Message tracing
 * Exchange interceptors
 * Auditing exchanges

 TODO: Create this

== SwitchYard - Testing SwitchYard application
 * Creating your own camel endpoint/component (Extensions)

 TODO: Create this

== SwitchYard - Advanced topics
 * Distributed transactions in FSW - what is possible and what is not possible (e.g. can a splitter/aggregator ever be transactional)

 TODO: Create this

== RTGov

 TODO: Create this


== DTGov

 * App building
 * life-cycle management
 * Deployment
 * Integrating the build/test/deployment process into a maven based build engine

 TODO: Create this

== Development
 
 * JBoss Developer Studio + IS plugins
 * Maven
 * Project structure (single project, multiproject, war, ear,...)

 TODO: Create this


== Operations
 
 * Installation (installer, silent,...)
 * Starting/stopping servers (server services)
 * Users
 * Multinode configuration (Multiple servers in one box
 * Databases
 * Management (Console, CLI, JMX, BPEL Console)
 * Monitoring
 * Troubleshooting

 TODO: Create this

== Thank you

That's all.

